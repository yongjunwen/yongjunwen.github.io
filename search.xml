<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RN原理解析]]></title>
    <url>%2F2018%2F06%2F15%2Freactnative%2FRN%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[react &amp; reactnative 图 android 原理分解链接 iOS 平台为例，剖析一下 React Native 的原理 基本原理概述 React Native 能够运行起来，全靠 Objective-C 和 JavaScript 的交互。 C 系列的语言，经过编译，链接等操作后，会得到一个二进制格式的可执行文，所谓的运行程序，其实是运行这个二进制程序。 JavaScript 是一种脚本语言，它不会经过编译、链接等操作，而是在运行时 才动态的进行词法、语法分析，生成抽象语法树(AST)和字节码，然后由解释器负责执行或者使用 JIT 将字节码转化为机器码再执行。整个流程由 JavaScript 引擎负责完成。 苹果提供了一个叫做 JavaScript Core 的框架，这是一个 JavaScript 引擎。iOS7中加入了JavaScriptCore.framework框架。把 WebKit 的 JavaScript 引擎用 Objective-C 封装。该框架让Objective-C和JavaScript代码直接的交互变得更加的简单方便。（注：JSCore，即JavaScriptCore，JS解析的核心部分，IOS使用的是内置的JavaScriptCore，Androis上使用的是 https://webkit.org/家的jsc.so。）JavaScriptCore和Objective-C 交互 JavaScript 是一种单线程的语言，它不具备自运行的能力，因此总是被动调用。很多介绍 React Native 的文章都会提到 “JavaScript 线程” 的概念，实际上，它表示的是 Objective-C 创建了一个单独的线程，这个线程只用于执行 JavaScript 代码，而且 JavaScript 代码只会在这个线程中执行。 Objective-C 与 JavaScript 交互obj-c 与 js调用关系图 交互流程 在 React Native 中，Objective-C 和 JavaScript 的交互都是通过传递 ModuleId、MethodId 和 Arguments 进行的。Objective-C 和 JavaScript 两端都保存了一份配置表，里面标记了所有 Objective-C 暴露给 JavaScript 的模块和方法。这样，无论是哪一方调用另一方的方法，实际上传递的数据只有 ModuleId、MethodId 和 Arguments 这三个元素，它们分别表示类、方法和方法参数，当 Objective-C 接收到这三个值后，就可以通过 runtime 唯一确定要调用的是哪个函数，然后调用这个函数。Objective-C 和 JavaScript 的交互总是由Objective-C发起的。Object-C与js的交互是通过各端的Bridge和ModuleConfig来进行的，实际过程可分为两个阶段：初始化阶段和方法调用阶段。 初始化 React Native 在RN（ios）项目中都会有 AppDelegate.m 这个文件，文件有如下代码： 用户能看到的一切内容都来源于这个 RootView，所有的初始化工作也都在这个方法内完成。在这个方法内部，在创建 RootView 之前，React Native 实际上先创建了一个 Bridge 对象。它是 Objective-C 与 JavaScript 交互的桥梁，后续的方法交互完全依赖于它，而整个初始化过程的最终目的其实也就是创建这个桥梁对象。 初始化方法的核心是 setUp 方法，而 setUp 方法的主要任务则是创建 BatchedBridge。BatchedBridge 的作用是批量读取 JavaScript 对 Objective-C 的方法调用，同时它内部持有一个 JavaScriptExecutor，顾名思义，这个对象用来执行 JavaScript 代码。创建 BatchedBridge 的关键是 start 方法，它可以分为五个步骤： 1.读取 JavaScript 源码 JavaScript 的代码是在 Objective-C 提供的环境下运行的，所以第一步就是把 JavaScript 加载进内存中，对于一个空的项目来说，所有的 JavaScript 代码大约占用 1.5 Mb 的内存空间。在这一步中，JSX 代码已经被转化成原生的 JavaScript 代码。 2.初始化模块信息 主要任务是找到所有需要暴露给 JavaScript 的类（Module） 初始化 JavaScript 代码的执行器，即 RCTJSCExecutor 对象 初始化JavaScript代码执行器，同时向 JavaScript 上下文中添加了一些 Block(Object-c中对闭包的实现) 作为全局变量。 3.Block–nativeRequireModuleConfig ： 它在 JavaScript 注册新的模块时调用： Block–nativeFlushQueueImmediate：一般情况下，Objective-C 会定时、主动的调用JS放到MessageQueue 中的方法，实际上（由于卡顿或某些特殊原因），JavaScript 也可以主动调用 Objective-C 的方法，目前，React Native 的逻辑是，如果消息队列中有等待 Objective-C 处理的逻辑，而且 Objective-C 超过 5ms 都没有来取走，那么 JavaScript 就会主动调用 Objective-C 的方法。 请牢牢记住这个 5ms，它告诉我们 JavaScript 与 Objective-C 的交互是存在一定开销的，不然就不会等待而是每次都立刻发起请求。其次，这个时间开销大约是毫秒级的，不会比 5ms 小太多，否则等待这么久就意义不大了。 4.生成模块列表并写入 JavaScript 端 让 JavaScript 获取所有模块的名字，作为一个全局变量存储 5.执行 JavaScript 源码 运行代码时，第三步中所添加的 Block（nativeRequireModuleConfig ） 就会被执行，从而向 JavaScript 端写入配置信息。 初始化工程 方法调用 1.OC调用 JS代码 OC不会直接调用实际的js函数，而是会去调用维系的中转函数，中转函数接收到 的参数包含了 ModuleId、MethodId 和 Arguments，就可以查找自己的模块配置表，找到真正要调用的 JavaScript 函数。 2.JS调用OC代码 在调用 Objective-C 代码时，JavaScript 会解析出方法的 ModuleId、MethodId 和 Arguments 并放入到 MessageQueue 中，等待 Objective-C 主动拿走，或者超时后主动发送给 Objective-C。 函数内部在每一次方调用中查找模块配置表找出要调用的方法，并通过 runtime 动态的调用。 React-Native简介与运行原理解析React Native通信机制详解]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN学习相关地址]]></title>
    <url>%2F2018%2F06%2F15%2Freactnative%2FRN%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[RN学习相关地址reactnative中文官网React之JSX语法crazycodeboy RN学习笔记RN学习应用与实践布局详细指南CSS布局ReactNative每日一学Flex布局介绍React Native 代码规范 前端扩展Flux 架构入门教程Redux 入门教程（一）：基本用法[JavaScript ES6基础语法] (http://es6.ruanyifeng.com/)[Redux介绍] (http://cn.redux.js.org/)MobX 简单、可扩展的状态管理 视频学习ReactNative基础与入门]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN脚手架初始化项目在0.45版本后问题]]></title>
    <url>%2F2018%2F06%2F15%2Freactnative%2FRN%E8%84%9A%E6%89%8B%E6%9E%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E5%9C%A80.45%E7%89%88%E6%9C%AC%E5%90%8E%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[由于 RN 0.45.0 后，需要依赖一些第三方库，这些库通过 npm 或 yarn 下载非常慢，所以可以先手动下载，放到此文件夹： ~/.rncache（如果路径不存在就手动创建一个） 首先配置npm镜像 地址跳转 如果依然失败的话 需要看以下步骤了。 以下是我用到的几个库（版本可能会有更新），如果手动下载有困难，可以找已经下载好的同学拿一下： 1234boost_1_63_0.tar.gzdouble-conversion-1.1.5.tar.gzfolly-2016.09.26.00.tar.gzglog-0.3.4.tar.gz react更新依赖的脚本在这个地方：react-native/scripts/ios-install-third-party.sh 百度网盘外链下载iOS RN 0.45以上版本所需的第三方编译库(boost等) 产生原因： ~/.rncache 中 boost_1_63_0.tar.gz， double-conversion-1.1.5.tar.gz， folly-2016.09.26.00.tar.gz， glog-0.3.4.tar.gz 文件下载不完整 node_modules/react-native/third-party 文件不完整 解决方案： 删除 .rncache 后重新下载，或手动下载后放入 .rncache 中 把以上文件解压后放入 node_modules/react-native/third-party 下]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative记录问题点]]></title>
    <url>%2F2018%2F06%2F15%2Freactnative%2FReactNative%E8%AE%B0%E5%BD%95%E9%97%AE%E9%A2%98%E7%82%B9%2F</url>
    <content type="text"><![CDATA[错误打印log的方法因为多了一个逗号：1234console.log('*************ZSDiscountHomeBrandCardView**str***************', +this.props.info)要删掉逗号就可以了 console.log('*************ZSDiscountHomeBrandCardView**str***************' +this.props.info) 注意：此种方式是异步操作不能立马打印出log1234567891011this.setState(&#123; cardList: tmpBrands&#125;)console.log('this.state.cardList=' + this.state.cardList)//此种方式可以打印出logthis.setState( &#123;cardList: tmpBrands&#125;, () =&gt; &#123; console.log('=》this.state.cardList=' + this.state.cardList) &#125;) RN中this所引起的undefined is not an object错误在我们编写RN代码的时候经常会出现一个错误，undefined is not an object(evaluating ‘this.refs’ ).undefined is not an object错误，提示我们未知的对象，该句话的含义就是我们没有定义该对象。但是this就是当前对象，为什么还会出现如此问题？只有一种可能，就是当前引用的this和this.setState的this不是指向同一个对象，这样才会出想“undefined is not an object”这样的错误。那么，今天我们来谈谈RN里的this，介绍几个特殊的case。 http://blog.csdn.net/codetomylaw/article/details/52215787 rn中Image不要用嵌套莫名在android上有很多问题 例如：设置边角弧度的时候在android上显示异常、加入jdrouter 页面布局错乱 hasOwnProperty 是否具有某个属性的使用1是否具有某个属性的使用 组件里 一定不能加分号12345678_renderErrorView () &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;NavigationBar Title="专属优惠"/&gt; &lt;JDNetworkErrorView onRetry=&#123;this._fetchData&#125;/&gt; ；//此处加分号就是错误的 &lt;/View&gt; );&#125; 导入react和JDReact方式import React, { Component, PropTypes } from 'react' import { StyleSheet, Text, View, Platform }from 'react-native' import { JDText, JDDevice, JDImage, JDTouchable, JDNativeToast } from '@jdreact/jdreact-core-lib']]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative使用记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative基础学习]]></title>
    <url>%2F2018%2F06%2F15%2Freactnative%2FReactNative%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[组件的生命周期组件装载，组件在渲染之前，会先调用默认的props，ES6就是，static defaultProps；接下来就是组件初始化，constructor（props）组件的构造方法；接下来是 componentWillMount组件在加载之前的方法；render完成组件的渲染；componentDidMount 组件渲染完成。接下来就进入运行阶段啦。（一次调用） 组件更新，在运行中，如果组件的属性发生了改变，就会调用 componentWillReceiveProps 会被调用，然后就会调用 shouldComponentUpdate ，询问我们是否要渲染组件，如果返回FALSE的话，就不会渲染；如果是TRUE的话，就会调用componentWillUpdate重新渲染组件，然后render，再后来就完成更新啦componentDidUpdate（多次调用） 组件卸载，页面关闭的时候，组件会被卸载，componentWillUnmount，可以完成资源的回收与释放啦。（一次调用） 创建组件的三种方式1234567891011121314151617181920212223242526272829/** 方式1 ES6* */export default class NewView extends Component&#123; render()&#123; return &lt;Text style=&#123;styles.container&#125;&gt;hello ES6&lt;/Text&gt; ; &#125;&#125;/* * 方式2 ES5 需要module.exports * */// var NewView = React.createClass(&#123;// render()&#123;// return &lt;Text style=&#123;styles.container&#125;&gt;hello ES5&lt;/Text&gt; ;// &#125;// &#125;)// module.exports = NewView;/* * 方式3 函数式 需要module.exports * 无状态，不能使用this，但是可以传入属性 * */// function NewView(props) &#123;// return &lt;Text style=&#123;styles.container&#125;&gt;hello &#123;props.name&#125;&lt;/Text&gt; ;// &#125;// module.exports = NewView; 组件的导入和导出1234567891011121314151617181920212223242526272829一、导出组件三种导出方式，之前学过的ES6, ES5, 函数式三种建立组件方式，里面有提及过如何导出使用方式：import EIComponent from &apos;./EIComponent&apos;二、导出变量方法一：export var name = &apos;sun&apos;;export var age = &apos;female&apos;;方法二：var name = &apos;sun&apos;;var age = &apos;22&apos;;export &#123;name, age&#125;;使用方式：例如setup.js中加入：import EIComponent,&#123;name,age&#125; from &apos;./EIComponent&apos;三、导出方法方法前加exportexport function sum(a,b)&#123; return a+b;&#125;使用方式：和变量使用方式一致import EIComponent,&#123;name,age,sum&#125; from &apos;./EIComponent&apos; React Native props使用详解123456789101112131415161718191、什么是props? 父组件传递给子组件的属性2、如何使用props?3、什么是默认属性以及它的作用？ 4、如何对props进行约束和检查？5、props使用小技巧之延展操作符？6、props使用小技巧之解构赋值？props使用技巧--延展操作符延展操作符是ES6中的新语法。当我要传递很多个属性时，let params = &#123;name:&apos;张&apos;，age:18, sex:&apos;女&apos; &#125;；使用的时候就是 &lt;PropsTest name=&#123;params.name&#125; sex=&#123;params.sex&#125; /&gt;（但这个非常的复杂，代码也会很长）&lt;PropsTest &#123; ...params &#125; /&gt;（使用 大括号里放三个点 ...，然后接着 params 就可以在下一个页面被使用了。 ）props使用技巧--解构赋值延展操作符是将属性全部进行赋值，但如果只想取出部分来进行赋值，就可以使用解构赋值。let params = &#123;name:&apos;张&apos;，age:18, sex:&apos;女&apos; &#125;；let &#123;name,sex&#125;=params; &lt;PropsTest name=&#123;name&#125; sex=&#123;sex&#125; /&gt; 它比传统的方式好是它可以从一组属性中获取指定属性，而且，少了一点点代码。 什么是state props是不可改变，只读的。为了实现交互，就需要用到组件的state。我们将组件看为状态机，UI是各种各样的状态，并在各种各样的状态之间可以切换，只需要改变组件的state，就会重新渲染UI。state是组件私有的，是没有办法通过其他组件传递过来的。 123456789101112state也可以吹气球（导入新的资源，都会报错，因此需要将包管理器关掉，再重新启动服务即可。）如何控制state的变化呢，在文字上设置方法，onPress=&#123; ()=&gt; &#123;this.setState (&#123; size:this.state.size+10&#125;); &#125;&#125; 改变state的值是用 this.setState&#123;size:90&#125;&lt;Image style=&#123;&#123;width:this.state.size,height:this.state.size&#125;&#125; source=&#123;require(&apos;./qiqiu.png)&#125;/&gt;上述代码就将 Image 的大小给渲染出来啦。(动态化的UI就有啦) 什么是refref是什么？ref是组件的特殊属性，组件被渲染后，指向组件的一个引用。可以通过组件的ref属性，来获取真实的组件。因为，组件并不是真正的DOM节点，而是存在于内存中的一种数据结构，称为虚拟的DOM，只有当它真正的插入文档之后，才变为真正的DOM节点。根据React的设计，所以的DOM变动都发生在虚拟DOM上，然后再将实际的部分反映到真实的DOM上–这就是 DOM DIff，它可以提高页面性能。 类 class类ES6中引入了class（类），让javaScript的面向对象编程变得更加简单和易于理解 一、类的导入和导入普通的组件是一样的import Student from ‘./Student’; 二、类的实例化可以在setup.js的构造函数中，如下：this.stu= new Student(“晓明”，”男”, 16); 三、使用类的实例setup.js的render里面 this.stu.getDescription()//获取实例中的方法或属性等 四、类的继承构造方法和方法是可以重写的]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React简介]]></title>
    <url>%2F2018%2F06%2F15%2Freactnative%2FReact%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[#React简介http://www.jianshu.com/p/1606f8bd46ed 背景介绍 Facebook认为MVC无法满足他们的扩展需求，由于他们非常巨大的代码库和庞大的组织，使得MVC很快变得非常复复杂，每当需要添加一项新的功能或特性时，系统的复杂度就成级数增长，致使代码变得脆弱和不可预测，结果导致他们的MVC正在土崩瓦解。认为MVC不适合大规模应用，当系统中有很多的模型和相应的视图时，其复杂度就会迅速扩大，非常难以理解和调试，特别是模型和视图间可能存在的双向数据流动。 React特点 1、作为UI React可以作为MVC中的View层进行使用，并且在已有项目中很容易使用React开发新功能。2、虚拟domVirtual DOM 虚拟DOM传统的web应用，操作DOM一般是直接更新操作的，但是我们知道DOM更新通常是比较昂贵的。而React为了尽可能减少对DOM的操作，提供了一种不同的而又强大的方式来更新DOM，代替直接的DOM操作。就是Virtual DOM,一个轻量级的虚拟的DOM，就是React抽象出来的一个对象，描述dom应该什么样子的，应该如何呈现。通过这个Virtual DOM去更新真实的DOM，由这个Virtual DOM管理真实DOM的更新。 为什么通过这多一层的Virtual DOM操作就能更快呢？ 这是因为React有个diff算法，更新Virtual DOM并不保证马上影响真实的DOM，React会等到事件循环结束，然后利用这个diff算法，通过当前新的dom表述与之前的作比较，计算出最小的步骤更新真实的DOM。3、组件化Components 组件在DOM树上的节点被称为元素，在这里则不同，Virtual DOM上称为commponent。Virtual DOM的节点就是一个完整抽象的组件，它是由commponents组成。 component 的使用在 React 里极为重要, 因为 components 的存在让计算 DOM diff 更高效。 学习准备1231、前端基础知识：html、css、JavaScript2、jsx语法知识3、es6 相关知识 React和ReactNative关系 react用于web应用开发，rn采用React方式进行移动应用开发。rn采用React语法，用于进行JavaScript跨终端应用开发，即拥有原生native的交互体验，又能够保留React自由的开发效率，使用灵活的的html和css布局，使用React语法结构组件，然后同时运行在ios和android平台上。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如果某个端口已被占用 如何查看和关闭]]></title>
    <url>%2F2018%2F06%2F15%2Freactnative%2F%E7%AB%AF%E5%8F%A3%E6%9F%A5%E7%9C%8B%E5%92%8C%E5%85%B3%E9%97%AD%2F</url>
    <content type="text"><![CDATA[如果某个端口已被占用 如何查看和关闭查看：lsof -i :8081 关闭：kill -9]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ESLint安装使用流程]]></title>
    <url>%2F2018%2F06%2F14%2Freactnative%2FESLint%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[ESLint安装使用流程 京东通天塔项目安装使用流程12345&gt; 京东通天塔项目已经添加了相关的配置只需要做以下操作即可使用：1. npm run install_eslint_packages 安装相关依赖包2. IDE配置： http://139.199.180.74/showdoc/Public/Uploads/2017-12-12/5a2f4a15bfbcd.jpeg3.输出使用 详见最底部 `ESLint输出报告方式` 新项目安装使用流程ESLint流程梳理一、背景介绍ESLint是一个用来识别 ECMAScript 并且按照规则给出报告的代码检测工具，使用它可以避免低级错误和统一代码的风格。ESLint被设计为完全可配置的，主要有两种方式来配置ESLint：1234567891011121314151617181920在注释中配置：使用JavaScript注释直接把配置嵌入到JS文件中。配置文件：使用下面任一的文件来为全部的目录和它的子目录指定配置信息。javascript：使用.eslintrc.js文件并导出一个包含配置的对象。YAML：.eslintrc.yaml或者.eslintrc.ymlJSON：.eslintrc.json，并且此文件允许使用JS形式的注释废弃的用法：.eslintrc，此文件可以是JSON或者YAMLpackage.json：在package.json文件中创建eslintConfig属性，所有的配置包含在此属性中。这些文件的优先级则是按照以上出现的顺序（.eslintrc.js &gt; .eslintrc.yaml &gt; .eslintrc.yml &gt; .eslintrc.json &gt; .eslintrc &gt; package.json）。三种方法可以配置ESLint &gt; 使用.eslintrc.*文件（ 支持JSON和YAML两种语法） &gt; 在package.json中添加eslintConfig配置块 &gt; 使用JavaScript注释直接把配置嵌入到文件中可以被配置的信息主要分为3类：Environments：你的 javascript 脚步将要运行在什么环境（如：nodejs，browser，commonjs等）中。Globals：执行代码时脚步需要访问的额外全局变量。Rules：开启某些规则，也可以设置规则的等级。 二、作用123456789EsLint提供以下几种校验：语法错误校验不重要或丢失的标点符号，如分号没法运行到的代码块（使用过WebStorm的童鞋应该了解）未被使用的参数提醒漏掉的结束符，如&#125;确保样式的统一规则，如sass或者less检查变量的命名 三、安装12345678910安装全局安装npm i -g eslint局部安装（推荐）npm i -D eslint安装完毕后，接下来新建一个配置文件.eslintrc.js，或者使用如下的命令行来自动生成。eslint --init 四、配置指定执行环境12345678910111213JavaScript 代码可以运行在浏览器或 nodejs 等环境中，每个环境的全局变量都不尽相同（如 nodejs 中没有 DOM 相关的全局变量）。在配置文件中可以自由的指定执行环境。// .eslintrc.jsmodule.exports = &#123; env: &#123; browser: true, node: true, &#125;,&#125;;https://eslint.org/docs/user-guide/configuring#specifying-environments 指定全局变量12345678910111213可以在配置文件或注释中指定额外的全局变量，false表明变量只读：使用注释来配置：/* global var1, var2 *//* global var1:false, var2:false */使用配置文件来配置：// .eslintrc.jsmodule.exports = &#123; globals: &#123; var1: true, var2: true, &#125;,&#125;; 配置Rules123456789在配置文件中可以设置一些规则。这些规则的等级有三种：&quot;off&quot; 或者 0：关闭规则。&quot;warn&quot; 或者 1：打开规则，并且作为一个警告（不影响exit code）。&quot;error&quot; 或者 2：打开规则，并且作为一个错误（exit code将会是1）。默认校验的地址http://eslint.org/docs/rules/ 五、使用方法1234通过命令行工具来使用 eslint 。1、列出所有文件命令 eslint .2、列出具体某个文件eslint [options] file.js [file.js] [dir] 六、自动修复1eslint --fix [dir] 七、相关插件使用ESLint输出报告方式一、终端直接输出方式：1eslint . 二、md格式：(到eslint_report目录下查看md格式文件)1eslint run eslint_makdown 三、html格式：（到eslint_report目录下查看html格式文件）1eslint run eslint_html]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>ESLint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring注解]]></title>
    <url>%2F2018%2F06%2F11%2Fjava%2Fspring%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[背景121、大量的XML让开发者厌恶,因此Spring提供了许多注解来完成各种功能。2、大量的注解让开发者厌恶 ,因此Spring提供了组合注解来完成各种功能。 Spring Boot 注解的意义以及作用12345利用注解：隐式配置，例如：@Autowired、@Bean、@Component等，通过注解来简化xml文件。利用Java文件：显示配置，比xml配置的优势是具备类型安全。利用传统的xml配置文件。 注解(annotations)列表 @ResponseBody 1用该注解修饰的函数，会将结果直接填充到HTTP的响应体中，一般用于构建RESTful的api； @Controller 1用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层）。 @RestController 1@ResponseBody和@Controller的合集 @RequestMapping 1提供路由信息，负责URL到Controller中的具体函数的映射。 更多注解详看]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh]]></title>
    <url>%2F2018%2F06%2F11%2Fgit%2Fgit%20%E4%B9%8B%20ssh%2F</url>
    <content type="text"><![CDATA[SSH你拥有了一个 GitHub 账号之后，就可以自由的 clone 或者下载其他项目，也可以创建自己的项目，但是你没法提交代码。仔细想想也知道，肯定不可能随意就能提交代码的，如果随意可以提交代码，那么 GitHub 上的项目岂不乱了套了，所以提交代码之前一定是需要某种授权的，而 GitHub 上一般都是基于 SSH 授权的。那么什么是 SSH 呢？ 简单点说，SSH是一种网络协议，用于计算机之间的加密登录。目前是每一台 Linux 电脑的标准配置。而大多数 Git 服务器都会选择使用 SSH 公钥来进行授权，所以想要在 GitHub 提交代码的第一步就是要先添加 SSH key 配置。 生成SSH keyLinux 与 Mac 都是默认安装了 SSH ，而 Windows 系统安装了 Git Bash 应该也是带了 SSH 的。大家可以在终端（win下在 Git Bash 里）输入 ssh 检测是否已安装。 紧接着输入 ssh-keygen -t rsa 或者（ssh-keygen -t rsa -C “邮箱名&quot;） ，什么意思呢？就是指定 rsa 算法生成密钥，接着连续三个回车键（不需要输入密码），然后就会生成两个文件 id_rsa 和 id_rsa.pub ，而 id_rsa 是密钥，id_rsa.pub 就是公钥。这两文件默认分别在如下目录里生成：Linux/Mac 系统 在~/.ssh 下，win系统在 /c/Documents and Settings/username/.ssh 下，都是隐藏文件，相信你们有办法查看的。接下来要做的是把 id_rsa.pub的内容添加到 GitHub 上，这样你本地的 id_rsa 密钥跟 GitHub 上的 id_rsa.pub 公钥进行配对，授权成功才可以提交代码。 GitHub 上添加 SSH key第一步先在 GitHub 上的设置页面，点击最左侧 SSH and GPG keys ： 怎么查看 id_rsa.pub 文件的内容？Linux/Mac 用户执行以下命令：cd ~/.sshcat id_rsa.pub 测试是否okSSH key 添加成功之后，输入 ssh -T git@github.com 进行测试 ssh向GITHUB 提交代码]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git gitignore的设置]]></title>
    <url>%2F2018%2F06%2F11%2Fgit%2F%E6%B7%BB%E5%8A%A0%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在项目中添加.gitignore文件 .gitignore文件可以直接从 https://github.com/github/gitignore 上面下载，里面包含了各个语言对应的.gitignore文件 配置添加所需要忽略的文件或者文件类型 使用命令vim .gitignore打开.gitignore文件，回车后 添加和修改要忽略的文件 将.gitignore文件提交到仓库123git add .gitignoregit commit -m &quot;添加项目忽略文件&quot;git push 提交.gitignore文件的目的主要是保证其他开发者提交的时候也会自动筛选掉不需要的文件，因为已提交到仓库的文件再设置.gitignore文件中忽略是无效的，需要先将其移除版本控制后，.gitignore文件才会生效。具体方法见下文。 关于 git 将文件或文件夹移除版本控制1234git rm -r -n --cached &quot;bin/&quot; //-n：加上这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。git rm -r --cached &quot;bin/&quot; //最终执行命令. git commit -m&quot; remove bin folder all file out of control&quot; //提交git push //提交到远程服务器 如果是要忽略一种类型的文件（如.DS_Store文件），将bin/换成*.DS_Store即可。 设置Git全局忽略文件方法配置全局忽略文件的我们就不必给每一个项目添加单独的忽略文件1、 进入用户目录下，将第一步中配置好的.gitignore文件拷贝到用户目录下，将这个文件改个名字，名字随意，自己好认就行2、 执行命令git config –global core.excludesfile ~/.gitignore_globalxxxx 补充命令git config –global core.excludesfile ~/.gitignore_globalaaaa的效果其实就是修改了在用户目录下的.gitconfig文件]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>gitignore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 本地仓库 更换远程仓库]]></title>
    <url>%2F2018%2F06%2F11%2Fgit%2Fgit%20%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%20%E6%9B%B4%E6%8D%A2%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[常用 Git 命令清单 git修改远程仓库地址的三种方法直接命令修改1git remote set-url origin [url] 命令，先删除后设新地址123git remote rm origin git remote add origin [url] 直接修改配置文件12345678910111213141516171819文件位置：git/config config[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[gui] wmstate = normal geometry = 841x483+225+101 189 218[remote &quot;origin&quot;] url = git@github.com:project.git fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;] remote = origin merge = refs/heads/master 补充：如果用sourcetree的话可以直接修改远程仓库地址]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>更换远程仓库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[icon生成脚本]]></title>
    <url>%2F2018%2F06%2F11%2FiOS%2F%20icon%E7%94%9F%E6%88%90%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[autoExportAppIconautoExportAppIconOne key to generate iOS app icon 标题 Useagepython /path/autoExportAppIcon.py /path/image.jpg New iOS App Icon show in finder replace the files.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIView与核心动画对比]]></title>
    <url>%2F2018%2F06%2F11%2FiOS%2FUIView%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[动画核心动画 UIView渐变动画 iOS核心动画高级技巧]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何判断代码运行在DEBUG还是RELEASE模式下？]]></title>
    <url>%2F2018%2F06%2F11%2FiOS%2F%20%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%9C%A8DEBUG%E8%BF%98%E6%98%AFRELEASE%E6%A8%A1%E5%BC%8F%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[首先确定下项目的 Build Settings 是否已经设置过宏定义 DEBUG，如何看呢？点击 Build Settings ，然后在搜索框里输入‘macros’ 如果已经设置过，在 Preprocessor Macros 的 Debug 后面会有 DEBUG=1，如果没有，就手动设置下。接下来就可以这样做了 12345#ifdef DEBUG //do sth.#else //do sth.#endif http://stackoverflow.com/a/9063682 一般Apple已经为我们设置好了 DEBUG 的宏定义，所以，我们只要让 NSLog 在 DEBUG 模式下失效就好了，这样能让我们的程序运行起来更加稳定，同时我们也可以继续使用正规的 NSLog。 1234567//put this in prefix.pch#ifndef DEBUG#undef NSLog#define NSLog(args, ...)#endif]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git项目中的常用功能]]></title>
    <url>%2F2018%2F06%2F11%2Fgit%2Fgit%20%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[列出提交个数 主要用来设置项目build号1git rev-list --count HEAD 获得两个版本间所有变更的文件列表12git diff 6962e097c87bcbd937eb59d94f9f79b9a709455d c02e20f5ad5eb1a675b6b3d30fed5b66f309871c --stat &gt; log.txt -p 查看某个文件的修改历史git log -p filePath/fileName.m 使用 pull rebase 操作替代 merge 如果你工作的团队正工作在同一个分支，那么你所要做的获取/合并或经常拉取。分支合并的 git 记录与合并提交时提示功能分支被并入主干。但在多个团队成员工作的同一分支的情况下，经常合并导致在日志中多个合并的消息引起混乱。所以你可以使用 pull rebase，以保持历史信息清除了无用合并的消息。 git config branch.BRANCH_NAME_HERE.rebase true 此外，您可以配置一个特定的分支总是衍合： git pull --rebase gc 命令“垃圾回收”是一个很亲切的功能。让我们开始吧：$ git gc --prune=now现在，重新检视一下仓库的大小，发现确实有效啊： 12345678910$ find .git/objects -type f.git/objects/info/packs.git/objects/pack/pack-9d75315485cb7bfbf51ce5c94a4535da99b58dbb.idx.git/objects/pack/pack-9d75315485cb7bfbf51ce5c94a4535da99b58dbb.pack$$ du -ah # 此处略去了无关输出4.0K ./.git/objects/pack/pack-9d75315485cb7bfbf51ce5c94a4535da99b58dbb.idx 52M ./.git/objects/pack/pack-9d75315485cb7bfbf51ce5c94a4535da99b58dbb.pack 77M ./bigfile130M . cherry-pick用法使用场景：在branch1开发，进行多个提交，这是切换到branch2，想把之前branch1分支提交的commit都复制过来。 单个commit只需要git cherry-pick commitid 多个commit 只需要git cherry-pick commitid1..commitid100 注意，不包含第一个commitid ， 即 git cherry-pick (commitid1..commitid100] Git更新远程分支列表git remote update origin --prune]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git删除缓存远程分支</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS linkmap统计ipa包]]></title>
    <url>%2F2018%2F06%2F11%2FiOS%2FiOS%20linkmap%E7%BB%9F%E8%AE%A1ipa%E5%8C%85%2F</url>
    <content type="text"><![CDATA[iOS APP编译后，除了一些资源文件，剩下的就是一个可执行文件，有时候项目大了，引入的库多了，可执行文件很大，想知道这个可执行文件的构成是怎样，里面的内容都是些什么，哪些库占用空间较高，可以用以下方法勘察： 1.XCode开启编译选项Write Link Map FileXCode -&gt; Project -&gt; Build Settings -&gt; 搜map -&gt; 把Write Link Map File选项设为yes，并指定好linkMap的存储位置 2.编译后，到编译目录里找到该txt文件，文件名和路径就是上述的Path to Link Map File位于~/Library/Developer/Xcode/DerivedData/XXX-eumsvrzbvgfofvbfsoqokmjprvuh/Build/Intermediates/XXX.build/Debug-iphoneos/XXX.build/这个LinkMap里展示了整个可执行文件的全貌，列出了编译后的每一个.o目标文件的信息（包括静态链接库.a里的），以及每一个目标文件的代码段，数据段存储详情。 在LinkMap里首先列出来的是目标文件列表：12345678910# Object files:[ 0] linker synthesized[ 1] /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator7.0.sdk/usr/lib/crt1.o[ 2] /Users/bang/Library/Developer/Xcode/DerivedData/yishu-eyzgphknrrzpevagadjtwpzzeqag/Build/Intermediates/yishu.build/Debug-iphonesimulator/yishu.build/Objects-normal/i386/TKPFileInfo.o...[280] /Users/bang/Downloads/yishu/yishu/Classes/lib/UMeng/MobClick/libMobClickLibrary.a(UMANJob.o)[281] /Users/bang/Downloads/yishu/yishu/Classes/lib/UMeng/MobClick/libMobClickLibrary.a(UMANWorker.o)[282] /Users/bang/Downloads/yishu/yishu/Classes/lib/UMeng/MobClick/libMobClickLibrary.a(MobClick.o)[283] /Users/bang/Downloads/yishu/yishu/Classes/lib/UMeng/MobClick/libMobClickLibrary.a(UMANLaunch.o)... 前面中括号里的是这个文件的编号，后面会用到，像项目里引用到静态链接库libMobClickLibrary.a里的目标文件都会在这里列出来。 接着是一个段表，描述各个段在最后编译成的可执行文件中的偏移位置及大小，包括了代码段（TEXT，保存程序代码段编译后的机器码）和数据段（DATA，保存变量值）12345678910111213141516171819202122232425262728293031323334# Sections:# Address Size Segment Section0x00002740 0x00273890 __TEXT __text0x00275FD0 0x00000ADA __TEXT __symbol_stub0x00276AAC 0x00001222 __TEXT __stub_helper0x00277CCE 0x00019D9E __TEXT __objc_methname0x00291A70 0x00012847 __TEXT __cstring0x002A42B7 0x00001FC1 __TEXT __objc_classname0x002A6278 0x000046A7 __TEXT __objc_methtype0x002AA920 0x000061CE __TEXT __ustring0x002B0AF0 0x00000764 __TEXT __const0x002B1254 0x000028B8 __TEXT __gcc_except_tab0x002B3B0C 0x00004EBC __TEXT __unwind_info0x002B89C8 0x0003662C __TEXT __eh_frame0x002EF000 0x00000014 __DATA __program_vars0x002EF014 0x00000284 __DATA __nl_symbol_ptr0x002EF298 0x0000073C __DATA __la_symbol_ptr0x002EF9E0 0x000030A4 __DATA __const0x002F2A84 0x00000590 __DATA __objc_classlist0x002F3014 0x0000000C __DATA __objc_nlclslist0x002F3020 0x0000006C __DATA __objc_catlist0x002F308C 0x000000D8 __DATA __objc_protolist0x002F3164 0x00000008 __DATA __objc_imageinfo0x002F3170 0x0002BC80 __DATA __objc_const0x0031EDF0 0x00003A30 __DATA __objc_selrefs0x00322820 0x00000014 __DATA __objc_protorefs0x00322834 0x000006B8 __DATA __objc_classrefs0x00322EEC 0x00000394 __DATA __objc_superrefs0x00323280 0x000037C8 __DATA __objc_data0x00326A48 0x000096D0 __DATA __cfstring0x00330118 0x00001424 __DATA __objc_ivar0x00331540 0x00006080 __DATA __data0x003375C0 0x0000001C __DATA __common0x003375E0 0x000018E8 __DATA __bss 首列是数据在文件的偏移位置，第二列是这一段占用大小，第三列是段类型，代码段和数据段，第四列是段名称。每一行的数据都紧跟在上一行后面，如第二行__symbol_stub的地址0x00275FD0就是第一行__text的地址0x00002740加上大小0x00273890，整个可执行文件大致数据分布就是这样。这里可以清楚看到各种类型的数据在最终可执行文件里占的比例，例如__text表示编译后的程序执行语句，__data表示已初始化的全局变量和局部静态变量，__bss表示未初始化的全局变量和局部静态变量，__cstring表示代码里的字符串常量，等等。 接着就是按上表顺序，列出具体的按每个文件列出每个对应字段的位置和占用空间12345# Address Size File Name0x00002740 0x0000003E [ 1] start0x00002780 0x00000400 [ 2] +[TKPFileInfo parseWithDictionary:]0x00002B80 0x00000030 [ 2] -[TKPFileInfo fileID]... 同样首列是数据在文件的偏移地址，第二列是占用大小，第三列是所属文件序号，对应上述Object files列表，最后是名字。例如第二行代表了文件序号为2（反查上面就是TKPFileInfo.o）的parseWithDictionary方法占用了1000byte大小。 使用这个文件可以让你了解整个APP编译后的情况，也许从中可以发现一些异常，还可以用这个文件计算静态链接库在项目里占的大小，有时候我们在项目里链了很多第三方库，导致APP体积变大很多，我们想确切知道每个库占用了多大空间，可以给我们优化提供方向。LinkMap里有了每个目标文件每个方法每个数据的占用大小数据，所以只要写个脚本，就可以统计出每个.o最后的大小，属于一个.a静态链接库的.o加起来，就是这个库在APP里占用的空间大小。 生成的linkmap文件path/Users/wenyongjun/Library/Developer/Xcode/DerivedData/JDViewKitProduct-cvqwuevthaoawvbqwonrghbfhnuz/Build/Intermediates.noindex/JDViewKitProduct.build/Debug-iphonesimulator/JDViewKitProduct.build/JDViewKitProduct-LinkMap-normal-x86_64.txt 基于LinkMap分析iOSAPP各模块体积 iOS APP可执行文件的组成]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode中和symbols有关的几个设置]]></title>
    <url>%2F2018%2F06%2F11%2FiOS%2FXcode%E4%B8%AD%E5%92%8Csymbols%E6%9C%89%E5%85%B3%E7%9A%84%E5%87%A0%E4%B8%AA%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[在iOS开发中 特别是有framework打包的时候 经常遇到包比较大的问题。下面就来开下Xcode中和symbols有关的几个设置。 简书地址 Generate Debug Symbols 修改为NO后 能减少包的大小 但是debug功能就不能使用了]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS之GCD]]></title>
    <url>%2F2018%2F06%2F11%2FiOS%2FiOS%20GCD%2F</url>
    <content type="text"><![CDATA[多用GCD 少用performSelector系列方法123456789101112131415161718192021222324252627//可以在运行时调用方法- (id)performSelector:(SEL)selector//可带一个参数- (id)performSelector:(SEL)selector withObject:(id)object//可带两个参数- (id)performSelector:(SEL)selector withObject:(id)object withObject:(id)object//可延时执行方法- (void)performSelector:(SEL)selector withObject:(id)argument afterDelay:(NSTimeInterval)delay//可放到另一个线程中执行- (void)performSelector:(SEL)selector onThread:(NSThread *)thread withObject:(id)argument waitUntilDone:(BOOL)wait- (void)performSelectorOnMainThread:(SEL)selector withObject:(id)argument waitUntilDone:(BOOL)wait //延后执行方法的两种实现方式：[self performSelector:@selector(doSomething) withObject:nil afterDelay:5.0]; dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC));dispatch_after(time, dispatch_get_main_queue(), ^(void)&#123; [self doSomething];&#125;); //把任务放在主线程执行的两种方式[self performSlectorOnMainThread:@selector(doSomething) withObject:nil waitUntilDone:NO]; dispatch_async(dispatch_get_main_queue(), ^&#123; [self doSomething];&#125;); 1、performSelector系列方法在内存管理方面容易有疏失。它无法确定将要执行的选择子具体是什么，因而ARC编译器也就无法插入适当的内存管理方法。2、performSelector系列方法所能处理的选择子太过局限了，选择子的返回值类型及发送给方法的参数个数都受到限制。3、如果想把任务放在另一个线程上执行，那么最好不要用performSelector系列方法，而是应该把任务封装到块里，然后调用GCD的相关方法来实现。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 静态库和动态库]]></title>
    <url>%2F2018%2F06%2F11%2FiOS%2FiOS%20%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[静态库和动态库的存在的形式 静态库：以.a 和 .framework为文件后缀名。 动态库：以.tbd(之前叫.dylib) 和 .framework 为文件后缀名。（系统直接提供给我们的framework都是动态库！） 理解：.a 是一个纯二进制文件，.framework 中除了有二进制文件之外还有资源文件。 .a ，要有 .h 文件以及资源文件配合， .framework 文件可以直接使用。总的来说，.a + .h + sourceFile = .framework。所以创建静态库最好还是用.framework的形式 静态库和动态库的区别 不同点： 静态库在链接时，会被完整的复制到可执行文件中，如果多个App都使用了同一个静态库，那么每个App都会拷贝一份，缺点是浪费内存。类似于定义一个基本变量，使用该基本变量是是新复制了一份数据，而不是原来定义的； 动态库不会复制，只有一份，程序运行时动态加载到内存中，系统只会加载一次，多个程序共用一份，节约了内存。类似于使用变量的内存地址一样，使用的是同一个变量； 共同点： 静态库和动态库都是闭源库，只能拿来满足某个功能的使用，不会暴露内部具体的代码信息从源代码到app 当我们点击了 build 之后，做了什么事情呢？ 预处理（Pre-process）：把宏替换，删除注释，展开头文件，产生 .i 文件。 编译（Compliling）：把之前的 .i 文件转换成汇编语言，产生 .s文件。 汇编（Asembly）：把汇编语言文件转换为机器码文件，产生 .o 文件。 链接（Link）：对.o文件中的对于其他的库的引用的地方进行引用，生成最后的可执行文件（同时也包括多个 .o 文件进行 link）。 引用]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS JavaScriptCore使用]]></title>
    <url>%2F2018%2F06%2F11%2FiOS%2FiOS%20JavaScriptCore%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[iOS JavaScriptCore使用JavaScriptCore是iOS7引入的新功能，JavaScriptCore可以理解为一个浏览器的运行内核，使用JavaScriptCore可以使用native代码（这里主要指objectiveC和swift）与js代码进行相互的调用，本文主要从几个方面进行了解。 native调用js代码 js调用native代码 异常处理 JavaScriptCore和webView的结合使用 要使用JavaScriptCore，首先我们需要引入它的头文件 #import &lt;JavaScriptCore/JavaScriptCore.h&gt;这个头里面引入了几个重要的对象 12345#import "JSContext.h"#import "JSValue.h"#import "JSManagedValue.h"#import "JSVirtualMachine.h"#import "JSExport.h" JSContext是JavaScript的运行上下文，他主要作用是执行js代码和注册native方法接口 JSValue是JSContext执行后的返回结果，他可以是任何js类型（比如基本数据类型和函数类型，对象类型等），并且都有对象的方法转换为native对象。 JSManagedValue是JSValue的封装，用它可以解决js和原声代码之间循环引用的问题 JSVirtualMachine 管理JS运行时和管理js暴露的native对象的内存 JSExport是一个协议，通过实现它可以完成把一个native对象暴漏给js native调用js代码先看下面常见的三种情况，之间执行js代码、执行文件或网络中的js代码、注册js方法再利用JSValue调用 12345678910111213141516171819202122232425262728//直接执行js代码- (void)evaluateScript &#123; //定义一个js并执行函数 JSValue *exeFunction1 = [self.jsContext evaluateScript:@"function hi()&#123; return 'hi' &#125;; hi()"]; //执行一个闭包js JSValue *exeFunction2 = [self.jsContext evaluateScript:@"(function()&#123; return 'hi' &#125;)()"];&#125;//执行一段js文件中的代码//更多的应用场景使用网络或者本地文件加载一段js代码，充分利用其灵活性- (void)evaluateScriptFromJSFile &#123; NSString * path = [[NSBundle mainBundle] pathForResource:@"core" ofType:@"js"]; NSString * html = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:nil]; JSValue *constructor = [self.jsContext evaluateScript:html];&#125;//注册js方法，然后在利用JSValue调用- (void)regiestJSFunction &#123; //注册一个函数 [self.jsContext evaluateScript:@"var hello = function()&#123; return 'hello' &#125;"]; //调用 JSValue *value1 = [self.jsContext evaluateScript:@"hello()"]; //注册一个匿名函数 JSValue *jsFunction = [self.jsContext evaluateScript:@" (function()&#123; return 'hello objc' &#125;)"]; //调用 JSValue *value2 = [jsFunction callWithArguments:nil];&#125; 这里有几个重要的地方需要说明。 jsContext执行evaluateScript方法后的返回值类型对于native来说，返回的类型都是JSValue，这是Native对js执行对象的统一封装类型，实际上他对应的js类型不同会导致它的使用方法也不相同，常见的类型比如返回数值类型和返回一个函数。如果是返回数值类型，JSValue也对应了一组转换的API可以把JSValue转换成任何对于的native对象，例如： 1234567- (NSArray *)toArray;- (NSDictionary *)toDictionary;- (NSDate *)toDate;- (NSString *)toString;- (NSNumber *)toNumber;- (uint32_t)toUInt32;- (id)toObject; … 还有很多就不一一列举如果返回的是一个函数类型，这可以使用 jsvalue callWithArguments方法进行js函数调用，例如： 1234//注册一个匿名函数 JSValue *jsFunction = [self.jsContext evaluateScript:@" (function() &#123; return 'hello objc' &#125;)"]; //调用 JSValue *value2 = [jsFunction callWithArguments:nil]; js是非常美妙的，主要这里的js是一段闭包代码，主要看下面两段代码的区别 12(function() &#123; return 'hello objc' &#125;)function() &#123; return 'hello objc' &#125; 第一行是一个闭包，在js中执行这段代码会返回一个函数，而第二行是定义一个函数，执行第二行的结果是定义了一个匿名函数，但是执行结果无返回值。所以执行下面这段代码时省略了()，那么jsFunction的值就会为空了，很多移动端研发工程师不熟悉js代码很容易出现这样的错误。 1JSValue *jsFunction = [self.jsContext evaluateScript:@" (function() &#123; return 'hello objc' &#125;)"]; 当然如果我们在运行时中定义一个函数，后面也是可以调用的，只是不是使用callWithArguments方法了，示例如下： 123[self.jsContext evaluateScript:@"var hello = function()&#123; return 'hello' &#125;"]; JSValue *value1 = [self.jsContext evaluateScript:@"hello()"]; 执行后的结果就是value1或得到一个string类型的值：“hello” js调用native代码js调用native代码之前需要native先注册接口，使用jsContext[“方法名”]就可以注册，后面是一个闭包，闭包可以定义函数参数，也可以使用 [JSContext currentArguments] 方法获取到所有函数调用的参数看一段例子：//注册js方法给Native调用 (void)regiestNativeFunction { //注册一个objc方法给js调用 self.jsContext[@”log”] = ^(NSString *msg){ NSLog(@&quot;js:msg:%@&quot;,msg); }; //另一种方式，利用currentArguments获取参数 self.jsContext[@”log”] = ^() { NSArray *args = [JSContext currentArguments]; for (id obj in args) { NSLog(@&quot;%@&quot;,obj); } }; //使用js调用objc [self.jsContext evaluateScript:@”log(‘hello,i am js side’)”];}block使用仍然需要注意循环引用的问题，所以在block中可以使用JSContext的静态方法 + (JSContext *)currentContext 获取到context初次之外，JSContext还可以获取到更多的内容，比如：currentCalleecurrentThiscurrentArgumentsglobalObjectcallee和this都是js中的对象，callee简单的说就是调用函数的对象，this类似于native中的self。当然，jsContext中下标不仅仅可以放函数，也可以放对象和数值，对于熟悉js代码的人也不会觉得奇怪，因为js中基本上不太区分对象，函数的概念，对象和函数都是一样的东西。除了使用jsContext下标方法暴露js对象以外，还可以使用JSExprot协议去把objc复杂对象转换成JSValue并暴露给js对象 JSExport对象的用法1: 首先自定义个协议继承自JSExprot，并定义需要暴露给js的属性和方法，比如： 123456@protocol JSPersonProtocol &lt;JSExport&gt;@property (nonatomic, copy) NSDictionary *data;- (NSString *)whatYouName;@end 2: 新建一个native对象，实现协议和方法,比如：.h 123456@interface Person : NSObject&lt;JSPersonProtocol&gt;@property (nonatomic, copy)NSString *name;- (NSString *)whatYouName;@end .m 123456789101112#import "Person.h"@implementation Person-(NSString *)whatYouName &#123; return @"my name is liuyanwei";&#125;-(NSString *)name &#123; return @"liuyanwei";&#125;@end 使用 12345- (void)useJSExprot &#123; Person *p = [[Person alloc]init]; self.jsContext[@"person"] = p; JSValue *value = [self.jsContext evaluateScript:@"person.whatYouName()"];&#125; 执行后的结果就是，value的值为：my name is liuyanwei 异常处理1234567//注册js错误处理- (void)jsExceptionHandler &#123; self.jsContext.exceptionHandler = ^(JSContext *con, JSValue *exception) &#123; NSLog(@"%@", exception); con.exception = exception; &#125;;&#125; JavaScriptCore和UIWebView的结合使用上面的代码都是基于JSContext的，如果声明了一个UIWebView，也可以使用UIWebView获取到JSContext对象，就可以使用JavaScriptCore的Api了，在UIWebView中获取JSContext的方法是： 1JSContext *context=[webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]; 不过遗憾的是WKWebView目前我还没有找到获取JSContext的方法，如果有知道的朋友也希望能联系我。 JSVirtualMachine在创建jscontext的时候，可以传入一个JSVirtualMachine对象，如果没有传入这个对象，会新建一个JSVirtualMachine对象。JSVirtualMachine主要有3个作用：1: 支持js并发，多个VM之间的js操作是并发的 1：使用JSVirtualMachine初始化的多个context，可以共享jsvalue对象 2：解决循环引用问题 注意，当我们 export 一个 OC 或 Swift object 到 JS 中时，不能在这个object 中存储对应的 JS values。这种行为会导致一个retain cycle，JSValue objects 持有他们对应的 JSContext 的强引用，JSContext 则持有export到JS的native object的强引用，即 native object(OC or Swift object) —&gt; JSValue —&gt; JSContext —&gt; native object参考 JavaScriptCore学习之JavaScriptCore iOS7新JavaScriptCore框架入门介绍 出自]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发中 const,static,extern用法总结]]></title>
    <url>%2F2018%2F06%2F11%2FiOS%2FiOS%E5%BC%80%E5%8F%91%E4%B8%AD%20const%2Cstatic%2Cextern%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[iOS开发中怎么使用const,static,extern3个关键字. constconst的作用: const 是一个左结合的类型修饰符，它与其左侧的类型修饰符一起为一个类型修饰符,表示该类型只读. 123456789101112131415161718修饰基本变量// 这两种写法是一样的，const只修饰右边的基本变量b const int b = 20; // b:只读变量 int const b = 20; // b:只读变量修饰指针变量// 两种方式一样 const int *p1; // *p1：只读 p1:只读 int const *p1; // *p1：只读 p1:只读 // const修饰指针变量p1 int * const p1; // *p1:变量 p1:常量 // 第一个const修饰*p1 第二个const修饰 p1 // 两种方式一样 const int * const p1; // *p1：常量 p1：常量 int const * const p1; // *p1：常量 p1：常量 简言之:沿着号划一条线，如果const位于的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。 staticstatic的作用: 修饰局部变量：延长局部变量的生命周期。局部变量只会生成一份内存,只会初始化一次。修饰全局变量:使其只能在本文件中访问。 externextern的作用: 声明和捕捉外部全局变量。联合使用static与const:声明一个静态的全局只读变量,(仅当前文件可访问且只读). 1static NSString * const key = @"name"; extern与const组合:定义全局只读变量，多个文件共享。 1234.h文件extern NSString * const king;.m文件NSString * const king = @"king" 来源const-static-extern]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之位移枚举和按位或按位与运算]]></title>
    <url>%2F2018%2F06%2F11%2FiOS%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%E4%BD%8D%E7%A7%BB%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%8C%89%E4%BD%8D%E6%88%96%E6%8C%89%E4%BD%8D%E4%B8%8E%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[位移枚举(可复选的枚举) 使用位移实现选项变量 Autoresizing 的系统枚举UIViewAutoresizing 讲述以下位移已经计算提前计算出来了二进制与十进制值为了方便下文使用 1234567891011121314151617typedef NS_OPTIONS(NSUInteger,UIViewAutoresizing)&#123; 二进制值 十进制 UIViewAutoresizingNone =0, 00000000 0 UIViewAutoresizingFlexibleLeftMargin =1&lt;&lt;0, 00000001 1 UIViewAutoresizingFlexibleWidth =1&lt;&lt;1, 00000010 2 UIViewAutoresizingFlexibleRightMargin =1&lt;&lt;2, 00000100 4 UIViewAutoresizingFlexibleTopMargin =1&lt;&lt;3, 00001000 8 UIViewAutoresizingFlexibleHeight =1&lt;&lt;4, 00010000 16 UIViewAutoresizingFlexibleBottomMargin=1&lt;&lt;5 00100000 32&#125;; 使用枚举定义选项,每个选项均可启用或禁用，使用上述方式来定义枚举值,每个枚举值所对应的二进制表示中，只有1个二进制位的值是1。用“按位或操作符”可组合多个选项 用 | 来隔开 1234aView.autoresizingMask=UIViewAutoresizingFlexibleTopMargin| UIViewAutoresizingFlexibleLeftMargin| UIViewAutoresizingFlexibleBottomMargin| UIViewAutoresizingFlexibleRightMargin; 而且每一个枚举对应的逻辑都会覆盖到 实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768-(void)todo:(UIViewAutoresizing)type&#123; if(type==0)&#123; NSLog(@"UIViewAutoresizingNone"); return; &#125;//更严谨的写法 if(type&amp;UIViewAutoresizingFlexibleLeftMargin == UIViewAutoresizingFlexibleLeftMargin)&#123; NSLog(@"UIViewAutoresizingFlexibleLeftMargin"); &#125; if(type&amp;UIViewAutoresizingFlexibleWidth)&#123; NSLog(@"UIViewAutoresizingFlexibleWidth"); &#125; if(type&amp;UIViewAutoresizingFlexibleRightMargin)&#123; NSLog(@"UIViewAutoresizingFlexibleRightMargin"); &#125; if(type&amp;UIViewAutoresizingFlexibleTopMargin)&#123; NSLog(@"UIViewAutoresizingFlexibleTopMargin"); &#125; if(type&amp;UIViewAutoresizingFlexibleHeight)&#123; NSLog(@"UIViewAutoresizingFlexibleHeight"); &#125; if(type&amp;UIViewAutoresizingFlexibleBottomMargin)&#123; NSLog(@"UIViewAutoresizingFlexibleBottomMargin"); &#125;&#125;-(void)viewDidLoad&#123; [superviewDidLoad]; // Do any additional setup after loading the view, typically from a nib. [self todo:UIViewAutoresizingFlexibleLeftMargin| UIViewAutoresizingFlexibleRightMargin| UIViewAutoresizingFlexibleHeight]; &#125; 结果输出 123UIViewAutoresizingFlexibleLeftMargin UIViewAutoresizingFlexibleRightMargin UIViewAutoresizingFlexibleHeight 二进制转十进制1101（2）=1*2^0+0*2^1+1*2^2+1*2^3=1+0+4+8=13转化成十进制要从右到左用二进制的每个数去乘以2的相应次方不过次方要从0开始 位移位运算如 UIViewAutoresizingFlexibleHeight = 1 &lt;&lt; 4, 1.左移运算 1 &lt;&lt; 4将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 1 转化为二进制为 :0000 0001 左移四位就为 :0001 0000 0001 0000 转化为十进制等于16 2.右移运算 90&gt;&gt;4将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。操作数每右移一位，相当于该数除以2。 90转化为二进制为 :01011010 右移4位就是 :00000101 00000101 转化为十进制等于5 按位或运算符（|）运算规则：0|0=0； 0|1=1； 1|0=1； 1|1=1；即 ：参加运算的两个二进制对应数位只要有一个为1，其值为1。 例如 123[self todo:UIViewAutoresizingFlexibleLeftMargin|UIViewAutoresizingFlexibleRightMargin| UIViewAutoresizingFlexibleHeight]; 1.十进制1|4|16 转为二进制0000 0001 | 0000 0100 | 0001 0000 = 0001 0101,因此，1|4|16的十进制值得21 按位与运算符（&amp;）参加运算的两个数据，按二进制位进行“与”运算。运算规则：0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1;即：两对应数位同时为“1”，结果才为“1”，否则为0 1.十进制3&amp;5 转为二进制 0000 0011 &amp; 0000 0101 = 0000 0001 因此，3&amp;5的值得1 2.iOS在方法中的应用 1234567-(void)todo:(UIViewAutoresizing)type&#123;if (type &amp; UIViewAutoresizingFlexibleLeftMargin ) &#123;NSLog(@"UIViewAutoresizingFlexibleLeftMargin");&#125;&#125;入参数type 为 UIViewAutoresizingFlexibleLeftMargin|UIViewAutoresizingFlexibleRightMargin|UIViewAutoresizingFlexibleHeight 上文知道结果是 0001 0101,十进制值得21 UIViewAutoresizingFlexibleRightMargin为4 0001 0101 &amp; UIViewAutoresizingFlexibleRightMargin = 0001 0101 &amp; 0000 0100 =21&amp;4 = 4 根据计算结果还是UIViewAutoresizingFlexibleRightMargin这个枚举 在iOS中的总结如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项值定义为2的幂，以便通过按位或操作将其组合起来。 用NS_ENUM与NS_OPTIONS宏来定义枚举类型，并指明其底层数据类型。这样做可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。 在处理枚举类型的switch语句中不要实现default分支。这样的话，加入新枚举之后，编译器就会提示开发者：switch语句并未处理所有枚举。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 加载http的方法]]></title>
    <url>%2F2018%2F06%2F11%2FiOS%2FiOS%20%E5%8A%A0%E8%BD%BDhttp%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在iOS 9的时候,默认非HTTS的网络是被禁止的,我们可以在info.plist文件中添加NSAppTransportSecurity字典,将NSAllowsArbitraryLoads设置为YES来禁用ATS 简书地址 解决方案一： 开启 NSAllowsArbitraryLoads 为 YES，然后提交时进行说明 解决方案二： 设置 NSExceptionDomains 属性来访问指定域名，然后提交时进行说明 解决方案三： 只针对网页浏览和视频播放的行为且为iOS 10及以上，设置NSAllowsArbitraryLoadsInWebContent为Yes。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OS 中的 armv7,armv7s,arm64,i386,x86_64 都是什么]]></title>
    <url>%2F2018%2F06%2F11%2FiOS%2FiOS%20%E4%B8%AD%E7%9A%84%20armv7%2Carmv7s%2Carm64%2Ci386%2Cx86_64%20%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[在做静态库的时候以及引用静态库的时候经常会遇到一些关于真机模拟器不通用的情况，会报错找不到相应库导致编译失败， 这里简单记录一下各种设备支持的架构。 iOS测试分为模拟器测试和真机测试，处理器分为32位处理器，和64位处理器模拟器模拟器32位处理器测试需要i386架构，（iphone5,iphone5s以下的模拟器） 模拟器64位处理器测试需要x86_64架构，(iphone6以上的模拟器) 真机真机32位处理器需要armv7,或者armv7s架构，（iphone4真机/armv7, ipnone5,iphone5s真机/armv7s） 真机64位处理器需要arm64架构。(iphone6,iphone6p以上的真机) project -&gt; target -&gt; building setting -&gt; Arhitectures 设置 设置debug属性设置为no的时候，会编译支持所有架构的版本，编译的速度会变慢，设置为yes 的时候，只编译当前的architecture版本，编译速度快。 一般情况下，debug 设置为yes，release为no，这样发行版本能适应不同设备。 用到的命令行查看或者合并静态库.a支持信息：lipo -info .a文件 两个静态库合并： lipo -create 文件1 文件2 -output /Users/sunjianfei/Desktop/libPrint.a]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS打包Framework真机和模拟器兼容合并版本]]></title>
    <url>%2F2018%2F06%2F11%2FiOS%2FiOS%E6%89%93%E5%8C%85Framework%E7%9C%9F%E6%9C%BA%E5%92%8C%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%85%BC%E5%AE%B9%E5%90%88%E5%B9%B6%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[查询framework支持哪些架构，命令为：1lipo -info XXXX.framework/XXXX 合并包123 lipo -create XXXX.framework/XXXX-armv7 XXXX.framework/XXXX-arm64 -output XXXX.framework/XXXXlipo -create 【模拟器打包path】 【真机打包path】 -output 【导出兼容版本path】 一键打包shell脚本1234567891011121314151617181920212223242526272829303132333435363738394041### 使用方法 ##### bash get_framework.sh##### 填写要生成的包的名字FrameWorkName="JDViewKit"# 设置输出包的文件路径OutputDir=$&#123;SRCROOT&#125;/VKOutput# Working dir will be deleted after the framework creation.buildDir=buildDEVICE_DIR=$&#123;buildDir&#125;/Release-iphoneosSIMULATOR_DIR=$&#123;buildDir&#125;/Release-iphonesimulator/$&#123;FrameWorkName&#125;.framework#编译真机和模拟器的两种架构# -configuration $&#123;CONFIGURATION&#125;# Clean and Building both architectures.xcodebuild -configuration "Release" -target "$&#123;FrameWorkName&#125;" -sdk iphoneos clean buildxcodebuild -configuration "Release" -target "$&#123;FrameWorkName&#125;" -sdk iphonesimulator clean build# 把旧的输出文件包删除掉if [ -d "$&#123;OutputDir&#125;" ]thensudo rm -rf "$&#123;OutputDir&#125;"fi# 创建输出包sudo mkdir -p "$&#123;OutputDir&#125;"sudo cp -R "$&#123;DEVICE_DIR&#125;/" "$&#123;OutputDir&#125;/"# 使用 lipo工具合并通用包（(i386 + armv6/armv7)）sudo lipo -create "$&#123;DEVICE_DIR&#125;/$&#123;FrameWorkName&#125;.framework/$&#123;FrameWorkName&#125;" "$&#123;SIMULATOR_DIR&#125;/$&#123;FrameWorkName&#125;" -output "$&#123;OutputDir&#125;/$&#123;FrameWorkName&#125;.framework/$&#123;FrameWorkName&#125;"# 删除build包 打开输出包文件夹sudo rm -r "$&#123;buildDir&#125;"open "$&#123;OutputDir&#125;"]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-ARC和垃圾回收机制的区别]]></title>
    <url>%2F2018%2F06%2F11%2FiOS%2Fios-ARC%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[在java中有个垃圾回收器，什么是垃圾回收器，就是在程序运行的期间，垃圾回收器会不断的去扫描堆中的对象是否无人使用。如果无人使用就会回收了。 ARC在编译的时候就会在合适的地方插入retain,release,autorelease,在运行的时候没有东西去进行实时检查，它插入的代码可以在对象没有人用的时候，引用计数器就会变为0.一旦变为0就会被销毁了。 如果在java中有一段代码是Person * p=[Person new]; p=nil，这个对象什么时候被回收？不一定，因为这要看垃圾回收器有没有扫描到这里。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆栈]]></title>
    <url>%2F2018%2F06%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%2F%E5%A0%86%E6%A0%88%2F</url>
    <content type="text"><![CDATA[在计算机领域，堆栈是一个不容忽视的概念，堆栈是两种数据结构。堆栈都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。在单片机应用中，堆栈是个特殊的存储区，主要功能是暂时存放数据和地址，通常用来保护断点和现场。要点：堆，队列优先,先进先出（FIFO—first in first out） 。栈，先进后出(FILO—First-In/Last-Out)。 堆栈空间分配栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。 堆栈缓存方式栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。 堆栈数据结构区别堆（数据结构）：堆可以被看成是一棵树，如：堆排序。栈（数据结构）：一种先进后出的数据结构。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS runtime]]></title>
    <url>%2F2018%2F06%2F11%2FiOS%2Fruntime%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[仓库地址dream001 demo仓库地址苹果官网开源代码官方api 掘金runtime实战总结IOS程序在main函数前所做的事情 maindevtang 深入理解Objective-C的Runtime机制]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列]]></title>
    <url>%2F2018%2F06%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%2F%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。 队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS总结的点]]></title>
    <url>%2F2018%2F06%2F11%2FiOS%2F%E6%80%BB%E7%BB%93%E7%9A%84%E7%82%B9%2F</url>
    <content type="text"><![CDATA[UIImage中 imageNamed 和 imageWithContentsOfFile的区别[UIImage imageNamed:]只适合与UI界面中小的贴图的读取，而一些比较大的资源文件应该尽量避免使用这个接口。直接读取文件路径[UIImage imageWithContentsOfFile]来解决图片的读取问题这两种方式的主要区别在于：imageName的方式会在使用的时候系统会cache，程序员是无法处理cache的，这是由系统自动处理的，对于重复加载的图像，速度会提升很多，这样反而用户体验好。所以如果某张图片需要在应用中使用多次，或者重复引用，使用imageName的方式会更好imageWithContentsOfFile的方式，在使用完成之后系统会释放，不会缓存下来，所以也就没有这样的问题。一般也不会把所有的图片都会缓存。有些图片在应用中只使用一两次的，就可以用这样的方式，比如新手引导界面的图片等等，就适合这样的方式。没有明显的界限。 CALayer 和 UIView的区别CALayer属于Core Animation部分的内容，比较重要而不太好理解。以下是园子中看到的一篇文章的摘录： UIView是iOS系统中界面元素的基础，所有的界面元素都是继承自它。它本身完全是由 CoreAnimation来实现的。它真正的绘图部分，是由一个CALayer类来管理。UIView本身更像是一个CALayer的管理器，访问它的跟绘图和跟坐标有关的属性，例如frame，bounds等，实际上内部都是在访问它所包含的CALayer的相关属性。 UIView有个重要属性layer，可以返回它的主CALayer实例。 如何定义一个不规则的button （还包含一个问题若干个button叠加在一起，苹果如何知道点击的是哪个button，实现原理？） 在iOS中通常使用hit-testing去找到那个被触摸的视图。这个视图叫hit-test view，当iOS找到hit-test view后就把touch event交个那个视图来处理。 用GCD的方式去实现有n个线程去访问一个属性，只有一个线程去修改属性NSRunloop的使用 那么具体什么是NSRunLoop呢？其实NSRunLoop的本质是一个消息机制的处理模式。 NSRunLoop是一种更加高明的消息处理模式 http://blog.csdn.net/cwq9944/article/details/8555104 CoreAnimation 与 UIViewAnimation分别何时会使用arc 和 gc 理解 ARC是iOS 5推出的新功能，全称叫 ARC(Automatic Reference Counting)。简单地说，就是代码中自动加入了retain/release，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了。 ARC基本规则 retain, release, autorelease, dealloc由编译器自动插入，不能在代码中调用dealloc虽然可以被重载，但是不能调用[super dealloc] 如何在ARC代码中混编非ARC代码 “ios中如果arc和非arc文件混编，可以在build parses中指定compile flags，如果arc文件设为”-fobjc-arc”,非arc文件设为”-fno-objc-arc”” 使用了ARC之后如果你想复用以前写过的使用MRC的类， 就会出报错。这时候怎么办？方法比较简单， 只需要做下面的一个步骤就可以解决： 在targets的build phases选项下Compile Sources下选择要不使用arc编译的文件，双击它，输入 -fno-objc-arc 即可 MRC工程中也可以使用ARC的类。方法如下： 在targets的build phases选项下Compile Sources下选择要使用arc编译的文件，双击它，输入 -fobjc-arc 即可 NSAutoreleasepool理解 iOS的运行时是由一个一个runloop组成的 每个runloop中都创建一个Autorelease Pool，并在runloop的末尾进行释放， 所以，一般情况下，每个接受autorelease消息的对象，都会在下个runloop开始前被释放。也就是说，在一段同步的代码中执行过程中，生成的对象接受autorelease消息后，一般是不会在代码段执行完成前释放的。 当然也有让autorelease提前生效的办法：自己创建Pool并进行释放 123NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];NSArray * array = [[[NSArray alloc] init] autorelease];[pool drain]; weak,block weak不增加引用，block增加引用 举例哦，某对象self，self的strong成员变量有blockA，blockA内部引用了self，如果self不经过__weak处理，就会变成： self强引用blockA，blockA强引用self。这不就循环引用了嘛 runtime由于runtime是更底层的语言，我们编写的OC代码在运行时，编译器内部会先转为C和C++的代码，然后再执行，因而运用runtime机制，程 序的性能也会更好。 123456789 @interface Person : NSObject&#123; CGFloat height;&#125;@property (nonatomic, copy) NSString *name;@property (nonatomic, strong) NSNumber *age;@property (nonatomic, assign) int no;@end 复制代码 然后，我们在其它文件中使用这个类，注意在使用之前，要包含 #import &lt;objc/message.h&gt; 下面通过一小段代码来获取到上面这个类中所有的成员变量 复制代码 1234567891011121314unsigned int outCount = 0; Ivar *vars = class_copyIvarList([Lender class], &amp;outCount); // 获取到所有的成员变量列表 // 遍历所有的成员变量 for (int i = 0; i &lt; outCount; i++) &#123; Ivar ivar = vars[i]; // 取出第i个位置的成员变量 const char *propertyName = ivar_getName(ivar); // 获取变量名 const char *propertyType = ivar_getTypeEncoding(ivar); // 获取变量编码类型 printf("---%s--%s\n", propertyName, propertyType); &#125; 什么是GCD？ Grand Central Dispatch或者GCD，是一套低层API，提供了一种新的方法来进行并发程序编写。从基本功能上讲， GCD有点像NSOperationQueue，他们都允许程序将任务切分为多个单一任务然后提交至工作队列来并发地或者串行地执行。GCD比之NSOpertionQueue更底层更高效，并且它不是Cocoa框架的一部分。 GCD的基本概念就是dispatch queue。dispatch queue是一个对象，它可以接受任务，并将任务以先到先执行的顺序来执行。dispatch queue可以是并发的或串行的。并发任务会像NSOperationQueue那样基于系统负载来合适地并发进行，串行队列同一时间只执行单一任务。 GCD中有三种队列类型： The main queue: 与主线程功能相同。实际上，提交至main queue的任务会在主线程中执行。main queue可以调用dispatch_get_main_queue()来获得。因为main queue是与主线程相关的，所以这是一个串行队列。 Global queues: 全局队列是并发队列，并由整个进程共享。进程中存在三个全局队列：高、中（默认）、低三个优先级队列。可以调用dispatch_get_global_queue函数传入优先级来访问队列。 用户队列: 用户队列 (GCD并不这样称呼这种队列, 但是没有一个特定的名字来形容这种队列，所以我们称其为用户队列) 是用函数 dispatch_queue_create 创建的队列. 这些队列是串行的。正因为如此，它们可以用来完成同步机制, 有点像传统线程中的mutex。 首先，我们要明确NSOperationQueue与GCD之间的关系 NSOpertaionQueue用GCD构建封装的，是GCD的高级抽象。 其次，我们要区别两者的不同 GCD仅仅支持FIFO队列，而NSOperationQueue中的队列可以被重新设置优先级，从而实现不同操作的执行顺序调整 http://www.dreamingwish.com/frontui/article/default/ios-multithread-program-runloop-the.html xcode：关于Other Linker Flags 关于Other Linker Flags xcode中，在“Targets”选项下有Other Linker Flags选项，在这里可以填写xcode链接器的参数，如：-ObjC、-all_load、-force_load等。 主要参数 这里要说的主要参数是ld工具的参数，也是在Other Linker Flags里常用到的参数。 1.-ObjC 当使用ObjC写的静态类别库（Objective-C static library that contains categories），在程序编译链接时，如果不在Other Linker Flags中填写-ObjC，往往会报错，出现”selector not recognized”。博主无力，原因看不太懂。具体原因请查阅xcode帮助文档。 -ObjC的作用是加载用ObjC实现的类、类别等所有成员。 2.-all_load 强制链接器加载所有包含非ObjC的目标文档。 -force_load 加载指定的目标文档。-force_load后面需要文档路径 __strong：会retain（强引用）__weak NSObject *obj;和assign类似，多一个功能：对象销毁后置为nil __autoreleasing：使对象延迟释放 __bridge:忽略所有的内存管理细节 Core Foundation需要使用桥接， Objective-C运行时定义了几种重要的类型。 Class：定义Objective-C类 Ivar：定义对象的实例变量，包括类型和名字。 Protocol：定义正式协议。 objc_property_t：定义属性。叫这个名字可能是为了防止和Objective-C 1.0中的用户类型冲突，那时候还没有属性。 Method：定义对象方法或类方法。这个类型提供了方法的名字（就是选择器）、参数数量和类型，以及返回值（这些信息合起来称为方法的签名），还有一个指向代码的函数指针（也就是方法的实现）。 SEL：定义选择器。选择器是方法名的唯一标识符。 IMP：定义方法实现。这只是一个指向某个函数的指针，该函数接受一个对象、一个选择器和一个可变长参数列表（varargs），返回一个对象 Objective-C Method Swizzling IOS 中方法重组相关常用方法，都在包内： //向类中添加MethodBOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types) //修改类的Method IMPclass_replaceMethod(Class cls, SEL name, IMP imp, const char *types) //交换2个方法中的IMPvoid method_exchangeImplementations(Method m1, Method m2) //获取类的某个实例方法Method class_getInstanceMethod(Class aClass, SEL aSelector);底层原理 在运行时，oc 的方法被称为一种叫 Method 的结构体，这种 objc_method 类型的结构体定义为： 12345struct objc_method &#123; SEL method_name OBJC2_UNAVAILABLE; char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Effective-Objective-C 2.0》]]></title>
    <url>%2F2018%2F06%2F11%2FiOS%2F%E3%80%8AEffective-Objective-C%202.0%E3%80%8B%2F</url>
    <content type="text"><![CDATA[图片原地址：https://upload-images.jianshu.io/upload_images/1457495-debf9e0c37687e51.png对应简书总结Effective-Objective-C 2.0.pdfiOS相关书籍汇总 分界线 说明：以下内容 均来自与jatstar的汇总 只做引用学习 没有商业用途 Effective-Objective-C 2.0 熟悉Objective-C 起源 由消息型语言鼻祖Smalltalk演化而来。是C语言的超集。 与函数式语言关键区别：消息结构的语言，运行时所执行的代码由运行环境决定(动态绑定)；函数调用的语言，由编译器决定。 NSString someString 中 someString为指向NSString 的指针。Type 声明的对象总是被分配的堆区(heap space) 中，而绝不可能分配的栈区(stack)。 如果只需保存int float double char 等非对象类型（nonoobject type） ，使用C结构体(如CGRect)比使用OC对象性能更优，因为创建OC对象需要分配及释放堆区内存等额外开销。 在类的头文件中尽量少引入其他头文件 头文件在类的头文件中，少引入头文件，使用@Class 向前声明即可。 然后在实现文件中再引入那些类的头文件。这样可以降低类之间的耦合。 无法使用向前声明的情况，如果 引入当前类遵守的某一项协议，此时把协议单独放下一个头文件中，再将其引入。 多用字面量语法，少用与之等价的方法。 举个🌰: 123456789101112NSNumber *intNumber = @1;NSNumber *floatNumber = @2.5f;NSArray *namesArray = @[@"Jat",@"Jay",@"Vae"];NSString *myName = namesArray[0];NSDictionary *personData = @&#123;@"ChineseName":@"张建宇",@"EnglishName":@"Jat",@"age":@"23"&#125;Number *myAge = personData[@"age"];//通过字面量创建的数组或者字典 ，如果值中有nil，会抛出异常。 多用类型常量，少用＃define 预处理指令。 ＃define定义的出来的常量，不包含类型信息，编译器需要再编译前执行查找替换，会增加编译时间。 只在当前类使用的常量，可以使用 static const 在.m中定义。 在头文件中使用extern来声明全局变量,并在相关实现文件中定义其值。命名时，通常使用于是相关的类名最为前缀。如 UITextFieldTextDidBeginEditingNotification 。 《iOS开发中 const,static,extern用法总结》 使用枚举来表示状态，选项，状态码 易懂的枚举名可以提高代码的可读性。 选项为多选时，使用二进制表示枚举值，以便通过按位或将其组合起来。🌰： UIInterfaceOrientationMask。 switch语句中，不要实现default分支。这样加入新的枚举之后，编译器会提示：switch语句没有处理所有枚举值。 消息／对象／运行时 理解“属性” 这一概念 Objective-C语法@property详解 在对象内部尽量直接访问实例变量。 直接访问实例变量不经过方法派发，比点语法快。 ⚠️直接访问copy修饰的属性，不会掉用setter方法，所以不会拷贝该属性。 ⚠️不会触发KVO通知。是否会产生问题，视情况而定。 初始化方法和dealloc方法中，总是应该直接访问。 ⚠️注意考虑懒加载的情况下，要使用点语法。 理解“对象等同性”这一概念。 ==比较的是指针地址是否一样。 特有的等同性判断方法，如isEqualToString比isEqual快一些。 相同的对象必须具有相同的哈希码，但是哈希码相同的对象未必相同。 不必逐条比较每个属性的哈希码，依情况，使用速度快，碰撞率低的算法。 以“类族模式”隐藏实现细节 例如UIButton 中的 + (instancetype)buttonWithType:(UIButtonType)buttonType. 可以把实现细节隐藏在一个公共的接口后面。 在既有类中使用关联对象存放自定义数据 理解objc_msgSend 的作用 Objective-c “动态绑定(dynamic binding)” 的特性使得所要调用的函数直到运行时才能确定。通过动态消息派发系统(dynamic message dicpatch system)来查出对应的方法并执行。 消息由接收者(receiver)，选择子(selecter)，以及参数构成。调用方法实际上相当于在给对象发送消息。 理解消息转发机制 //TODO： 待续 用方法调配技术调试黑盒方法 123456789101112131415161718192021222324//Category#import "NSString+Test.h"#import &lt;objc runtime.h=""&gt;@implementation NSString (Test)- (NSString*)eoc_myLowercaseString &#123; NSString *lowercase = [self eoc_myLowercaseString]; NSLog(@"%@ =&gt; %@", self, lowercase); return lowercase;&#125;// 不会死循环，因为eoc_myLowercaseString与lowercaseString方法互换了，运行时期间eoc_myLowercaseString选择子实际上对应的原有的lowercaseString方法实现。+ (void)load&#123; Method originalMethod = class_getInstanceMethod([NSString class],@selector(lowercaseString)); Method swappedMethod = class_getInstanceMethod([NSString class],@selector(eoc_myLowercaseString)); method_exchangeImplementations(originalMethod, swappedMethod);&#125;@end /* 测试一下：NSString *string = @"Hello World";NSString *textString = [string lowercaseString];Output:Hello World =&gt; hello world*/&lt;/objc&gt; 理解类对象的用意 //TODO: 待续 接口与API设计 使用前缀避免命名空间冲突。 提供全能初始化方法 提供一个全能初始化方法，并与文档中指明，其他初始化方法均调用此方法。 全能初始化方法与超类不同时，应该重写，冲突时，应该加上抛异常机制提示。 实现description方法 自定义类，覆写description方法，返回的字符串，NSLog时的显示该字符串； 重写debugDescription，改变调试控制台输出信息，默认为description方法的返回值。 尽量使用不可变对象。 使用清晰而且协调的命名方式 为私有方法名加前缀 给私有方法名加上前缀(虽然我感觉没必要～也没见过知名开源项目有加；但是爱老婆说按规范要加) 不要使用下划线做私有方法的前缀，因为这种做法是预留给苹果的。 理解Objective-C错误模型 只有发生使整个应用崩溃的严重错误时，才之用异常。 不那么严重的错误，可以指派委托方法来处理错误，也可以把错误信息放在NSError里，由NSLog输出。 理解NSCoding协议。 想令对象具有拷贝功能，需实现NSCoying协议；如果对象有可变版本，还需要实现NSMutableCopying协议。 浅拷贝之后的内容与原始内容指针地址相同，深拷贝之后的内容指向原始内容相关对象的一份拷贝。(深拷贝会逐个元素发送Copy消息，用拷贝得到元素创建Set); 通过委托与数据源协议进行对象间的通信。 @property(nonatomic,weak)id delegate 用weak修饰，，防止循环引用(retain cycle); 将类的实现代码分散到便于管理的数个分类之中。//易于管理 总是为第三方类的分类名称增加前缀。 勿在分类中声明属性。 封装数据所用的全部属性都定义在主接口里。 关联对象可以解决分类不能合成实例变量的问题。//本书作者认为此方法内存管理上容易出错，不是很推荐。 使用“class-continuation”分类 隐藏实现细节 //就是Extension吧，匿名的分类。 通过协议提供匿名对象。 //隐藏返回值类型 内存管理 理解引用计数 以ARC简化引用计数 在dealloc方法中只释放引用并移除监听(KVO和Notifications) 编写 “异常安全代码”时留意内存管理问题(即：使用@try...@catch语法时) 以弱引用避免保留环(retain cycle :循环引用) 以“自动释放池块”降低内存峰值。 用“僵尸对象”调试内存管理问题。 系统在回收对象时，可以不将其真正回收，而是把它转化为僵尸对象。 系统会修改对象的isa指针，令其指向特殊的僵尸类。僵尸类能够响应所有的选择子，打印一条包含消息内容以及接收者的消息，然后终止程序。 不要使用retainCount。(ARC模式下，此方法废弃了)。block与GCD //翻译成 块与大中枢派发也是醉了。。。 理解block这一概念。 语法结构： return_type (^block_name)(parameters) 默认情况下block外的变量需要在block中修改的，需要在声明时加__block修饰，但block修改其所在的类的成员变量时不需要加。 定义block时，它是分配在栈区的，所以。只在其作用域范围有效。调用copy拷贝到堆区之后可以和OC对象一样具备引用计数。由ARC去管理。 为常见的block类型创建typedef 12345678910typedef int(^SomeBlock)(BOOL flag,int value);//使用：SomeBlock block = ^ (BOOL flag,int value)&#123; if(flag)&#123; return value * 5; &#125;else&#123; return value *10; &#125;&#125; 使用handler block降低代码的分散程度。//如AFN中的网络请求回调 用block引用其所属对象时不要出现循环引用。 多用派发队列，少用同步锁。 派发队列可以用来表述同步语义(synchornization semantic),比使用@synchronized块和NSLock对象更简单。 使用同步和异步派发结合起来，可以实现与普通加锁一样的同步行为，而且不会阻塞执行异步派发的线程。 使用同步队列和栅栏块，可以让同步锁更加高效。 多用GCD,少用｀performSelector｀系列方法。 12345678SEL selector;if(/* some condition */)&#123; selector = @selector(foo);&#125;else if(/* some other condition */)&#123; selector = @selector(bar);&#125;else&#123; selector = @selecter(baz)&#125; /运行时才能确定调用列哪个方法，编译器没有办法在编译时按ARC的内存管理原则判定返回值是不是该释放，编译器没有添加释放操作。这将又可能导致内存泄漏 / 掌握GCD和NSOperationQueue的使用时机。 运行任务之前，可以用在NSOperation对象上调用cancel取消该任务。 可以指定任务间的依赖关系。 可以通过KVO监听NSOperation的属性。例如isFinished,isCancelled。 指定操作的优先级。 重用NSOperation对象。 通过Dispathtch Group机制，根据系统资源状况来执行任务。 使用dispatch_once来执行只需运行一次的线程安全代码。 12345678+(id)sharedInstance&#123; static SomeClass *sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(@onceToken,^&#123; sharedInstance = [[self alloc]init]; &#125;) return sharedInstance;&#125; 不要使用dispatch_get_current_queue(void);//调试还是可以用下的 系统框架 熟悉系统框架。 CFNetWork:提供C语言级别的网络通信能力，将BSDsocket抽象成易于使用的接口。 CoreAudio:提供的C语言API可用来操作设备上的音频硬件。 AVFoundation:处理音频视频的录制，回放。 CoreData:用于实现数据持久化。 CoreText:提供C语言接口，用于执行文字排版以及渲染操作。 多用block枚举，少用for循环。//block枚举本身通过GCD并发执行遍历，更高效。 对自定义其内存管理语义的cellection使用无缝桥接。 构建缓存时选用NSCache而非NSDictionary.// low memory时 NSCache会自动删减缓存 精简initalize和load的实现代码。 iOS平台上，当类或者分类载入系统时，会先调用+(void) load;同时实现时，先调类里面的，再调用分类里面的。 无法判断各个类载入的顺序，所以在load方法使用第三方类比较危险。 load方法会阻塞线程，所以要尽量精简里面的代码。 首次使用某个类是，会调用该类的+(void) initalize方法，可以覆写该方法做一些与类相关的初始化操作。但是同load一样，也应该尽量精简。 别忘了NSTimer会保留目标对象。//weakSelf大法打破循环就好了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIBezierPath画边角弧度]]></title>
    <url>%2F2018%2F06%2F11%2FiOS%2F%E7%94%BB%E8%BE%B9%E8%A7%92%E5%BC%A7%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[UIBezierPath123456789UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:m_newsIV.bounds byRoundingCorners:UIRectCornerTopLeft | UIRectCornerTopRight cornerRadii:CGSizeMake(10.0, 10.0)]; // Create the shape layer and set its path CAShapeLayer *maskLayer = [CAShapeLayer layer]; maskLayer.frame = m_newsIV.bounds; maskLayer.path = maskPath.CGPath; // Set the newly created shape layer as the mask for the image view's layer m_newsIV.layer.mask = maskLayer;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题库]]></title>
    <url>%2F2018%2F06%2F11%2FiOS%2F%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[简单的做下自我介绍1关注点：考察下介绍和简历是否一致，现场的把控和语言表达能力。 控制器的生命周期12345678910111213参考答案：1、 alloc 创建对象，分配空间2、init (initWithNibName) 初始化对象，初始化数据3、loadView 从nib载入视图 ，通常这一步不需要去干涉。除非你没有使用xib文件创建视图4、viewDidLoad 载入完成，可以进行自定义数据以及动态创建其他控件5、viewWillAppear 视图将出现在屏幕之前，马上这个视图就会被展现在屏幕上了6、viewDidAppear 视图已在屏幕上渲染完成7、dealloc 销毁 （通过该方法内还可以检测什么？ 答案：返回后看时候回调该函数 来判断是否有内存泄露）...要求：对生命周期要熟悉精通，中间可以根据情况自己把握 讨论具体某个函数 如何使UILabel显示多行？1参考答案：numberOfLines = 0 frame和bounds有什么不同？1参考答案：相对父 与 自身 assign、retain、copy、strong、weak什么时候用？区别？123456参考答案：assign 基本数据类型与代理使用retain 引用计数在用来的基础上加1copy 开辟个新的内存空间strong 相当于老版本的retain,而且可以不再需要做release操作了weak 相当于老版本的assign。但是只适应于对象 imageName与imageContentOfFile的区别12参考答案：后者没有缓存 适用于只需要一次使用 减少对系统内存的耗用情况 对于单元格重用的理解？1234参考答案：1、当屏幕上滑出屏幕时，系统会把这个单元格添加到重用队列中，等待被重用。2、当有新单元从屏幕外滑入屏幕内时，从重用队列中找看有没有可以重用的单元格，若有，就直接用，没有就重新创建一个。 Category的优缺点123参考答案：优点：可以不创建子类的前提下扩展方法、可以对比较胖的类进行拆分。缺点：如果和类的方法起的重名会覆盖类中的方法、不能添加实例变量。 Delegate、Notification、Block区别与使用场景1234参考答案：Delegate是一对一的回调机制Notification是一对多的对所有添加观察者的通知Block代码比较简洁不需要像代理一样定义协议方法 delegate针对one-to-one关系，并且reciever可以返回值给sender，notification 可以针对one-to-one/many/none,reciever无法返回值给sender.所以，delegate用于sender希望接受到reciever的某个功能反馈值，notification用于通知多个object某个事件。 GCD中队列都是哪几种？参考答案：以下四种队列 串行队列 并行队列 全局队列 主队列 DISPATCH_QUEUE_SERIAL DISPATCH_QUEUE_CONCURRENT dispatch_get_global_queue dispatch_get_main_queue 队列中的任务只会顺序执行 队列中的任务通常会并发执行 是系统的 在多线程开发中，使用主队列更新UI 有A、B 2个异步请求，如何判断A、B都完成执行？如果需要A、B顺序执行，该如何实现？12345678910参考答案：能说出group和group_notify即可dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, queue, ^&#123; /*任务A */ &#125;);dispatch_group_async(group, queue, ^&#123; /*任务B */ &#125;);dispatch_group_notify(group,dispatch_get_main_queue(), ^&#123; // 在A、B异步执行完成后，会回调这里&#125;);第二问：能说出把用串行队列即可 自动布局之autoresizingMask UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleBottomMargin含义和内部原理是怎么样的？12345参考答案：知道这段代码的表面含义：左右间距不变自动调整宽度 和 顶部间距不变其次知道枚举的状态和选项模式 外部通过按位或 内部实现是通过位与操作运算实现的（可要求拿笔书写大致内部实现代码流程） 什么是 RunLoop？123456789101112参考答案：从字面上讲就是运行循环，它内部就是do-while循环，在这个循环内部不断地处理各种任务。一个线程对应一个RunLoop，基本作用就是保持程序的持续运行，处理app中的各种事件。通过runloop，有事运行，没事就休息，可以节省cpu资源，提高程序性能。主线程的run loop默认是启动的。iOS的应用程序里面，程序启动后会有一个如下的main()函数int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125;然后顺势承接下一题 滑动tableview的时候 定时器不执行的原因？解决办法？12345和上一题做承接参考答案：首先：将NSTimer添加到主线程NSRunLoop的默认模式下，只有主线程是默认模式下才能执行NSTimer（滚动scrollView，RunLoop默认进入Tracking模式，所以NSTimer不会有效果）。其次：只要将 timer 添加到 Common 占位模式下，timer就可以在Default和UITrackingRunLoopMode模式下都能运行（Common是一个表示，它是将NSDefaultRunLoopMode 和 UITrackingRunLoopMode标记为了Common） 哪些情况下会造成内存泄露？12参考答案：A、B对象进行强引用、代理强引用、block循环引用、timer、N次循环造成的内存上涨(autoReleasePool添加) 、用到Core Foundation对象（CFRelease）等。 Runtime实现的机制是什么，一般用于什么场景？1234567891011参考答案：1). 使用时需要导入的头文件 &lt;objc/message.h&gt; &lt;objc/runtime.h&gt;2). Runtime 运行时机制，它是一套C语言库。3). 实际上我们编写的所有OC代码，最终都是转成了runtime库的东西。应用场景： （1）获取类里面的所有成员变量。 （2）为类动态添加成员变量。 （3）动态改变类的方法实现。 （4）为类动态添加新的方法等。用于模型抽象 什么是 Method Swizzle？123456789参考答案：1). 在没有一个类的实现源码的情况下，想改变其中一个方法的实现，除了继承它重写、和借助类别重名方法暴力抢先之外，还有更加灵活的方法 Method Swizzle。2). Method Swizzle 指的是改变一个已存在的选择器对应的实现的过程。OC中方法的调用能够在运行时通过改变，通过改变类的调度表中选择器到最终函数间的映射关系。3). 在OC中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用OC的动态特性，可以实现在运行时偷换selector对应的方法实现。4). 每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的方法实现。5). 我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP。6). 我们可以利用 class_replaceMethod 来修改类。7). 我们可以利用 method_setImplementation 来直接设置某个方法的IMP。8). 归根结底，都是偷换了selector的IMP。 通过简历中开发过的项目，了解下项目分工和面试者负责的模块，怎么进行开发、维护的？1参考答案：对负责的模块应该有清晰的思路 在iOS中业务模块的编程风格是怎样的？1234参考答案：MVC、业务逻辑与用户界面分离、代码按区区域划分、多用组合、用类别防止类过胖保持易维护易扩展等等（只要编程习惯保证代码的简洁性、可阅读下皆可） 良好的编程风格可减少内存泄露和其它bug的出现。 最近在技术方面最有成就感的事？或者说最有成就感的项目是哪个？12参考答案：一般为攻破了某个技术难题。可以针对面试者开发的项目 多聊聊 了解下面试者的思路。 上面的技术难题怎么攻破的？12参考答案：了解该面试者解决问题的方式、渠道。 未来几年的职业规划？123参考答案：暂无具体 （多聊聊 感受下性格以及与人相处，至于职业规划只要符合部门的需要即可） 问下面试者他想了解哪些？1目的：了解下面试者的诉求、看他对公司是否有兴趣、看性格和表达能力]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解KVO底层实现]]></title>
    <url>%2F2018%2F06%2F11%2FiOS%2F%E8%AF%A6%E8%A7%A3KVO%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一、KVO (Key-Value Observing)KVO 是 Objective-C 对观察者模式（Observer Pattern）的实现。也是 Cocoa Binding 的基础。当被观察对象的某个属性发生更改时，观察者对象会获得通知。 有意思的是，你不需要给被观察的对象添加任何额外代码，就能使用 KVO 。这是怎么做到的？ 二、 KVO内部实现原理KVO是基于runtime机制实现的当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制如果原类为Person，那么生成的派生类名为NSKVONotifying_Person每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey:一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey:会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。补充：KVO的这套实现机制中苹果还偷偷重写了class方法，让我们误认为还是使用的当前类，从而达到隐藏生成的派生类 三、补充： 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？（看链接）如何自己动手实现 KVO 四、附注: KVC底层实现原理(如下)KVC运用了一个isa-swizzling技术. isa-swizzling就是类型混合指针机制, 将2个对象的isa指针互相调换, 就是俗称的黑魔法.KVC主要通过isa-swizzling, 来实现其内部查找定位的. 默认的实现方法�由NSOject提供isa指针, 如其名称所指,(就是is a kind of的意思), 指向分发表对象的类. 该分发表实际上包含了指向实现类中的方法的指针, 和其它数据。 具体主要分为三大步第一步：寻找该属性有没有setsetter方法？有，就直接赋值第二步：寻找有没有该属性带下划线的成员属性？有，就直接赋值第三步：寻找有没有该属性的成员属性？有，就直接赋值或者这么说1、首先搜索setKey:方法.(key指成员变量名, 首字母大写)2、上面的setter方法没找到, 如果类方法accessInstanceVariablesDirectly返回YES. 那么按 _key, _isKey，key, iskey的顺序搜索成员名.(NSKeyValueCodingCatogery中实现的类方法, 默认实现为返回YES)3、如果没有找到成员变量, 调用setValue:forUnderfinedKey:比如说如下的一行KVC的代码： 举个🌰e.g: 123456789[object setValue:@"13123" forKey:@"uuid"]; 就会被编译器处理成:// 首先找到对应selSEL sel = sel_get_ uuid("setValue:forKey:");// 根据object-&gt;isa找到sel对应的IMP实现指针IMP method = objc_msg_lookup (object-&gt;isa,sel);// 调用指针完成KVC赋值method(object, sel, @"13123", @"uuid"); 如何为一个实例动态替换方法资料根据kvo的实现原理：派生个实例方法所在类的子类，创建hook函数，然后修改isa指针object_setClass(instance, newClass);，实现替换的方法实现。 详解KVO底层实现代码实现仓库地址]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解iOS App的启动过程]]></title>
    <url>%2F2018%2F06%2F11%2FiOS%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3iOS%20App%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[深入理解iOS App的启动过程 准备知识 知道概念Mach-O哪些名词指的是Mach-o ? Executable 可执行文件 Dylib 动态库 Bundle 无法被连接的动态库，只能通过dlopen()加载 Image 指的是Executable，Dylib或者Bundle的一种，文中会多次使用Image这个名词。 Framework 动态库和对应的头文件和资源文件的集合 Apple出品的操作系统的可执行文件格式几乎都是mach-o，iOS当然也不例外。mach-o可以大致的分为三部分： Header 头部，包含可以执行的CPU架构，比如x86,arm64 Load commands 加载命令，包含文件的组织架构和在虚拟内存中的布局方式 Data，数据，包含load commands中需要的各个段(segment)的数据，每一个Segment都得大小是Page的整数倍。 那么Data部分又包含哪些segment呢？绝大多数mach-o包括以下三个段（支持用户自定义Segment，但是很少使用） __TEXT 代码段，只读，包括函数，和只读的字符串，上图中类似__TEXT,__text的都是代码段 __DATA数据段，读写，包括可读写的全局变量等，上图类似中的__DATA,__data都是数据段 __LINKEDIT __LINKEDIT包含了方法和变量的元数据（位置，偏移量），以及代码签名等信息。 dyld dyld的全称是dynamic loader，它的作用是加载一个进程所需要的image，dyld是开源的。 Virtual Memory 虚拟内存是在物理内存上建立的一个逻辑地址空间，它向上（应用）提供了一个连续的逻辑地址空间，向下隐藏了物理内存的细节。虚拟内存使得逻辑地址可以没有实际的物理地址，也可以让多个逻辑地址对应到一个物理地址。虚拟内存被划分为一个个大小相同的Page（64位系统上是16KB），提高管理和读写的效率。 Page又分为只读和读写的Page。 虚拟内存是建立在物理内存和进程之间的中间层。在iOS上，当内存不足的时候，会尝试释放那些只读的Page，因为只读的Page在下次被访问的时候，可以再从磁盘读取。如果没有可用内存，会通知在后台的App（也就是在这个时候收到了memory warning），如果在这之后仍然没有可用内存，则会杀死在后台的App。 Page fault 在应用执行的时候，它被分配的逻辑地址空间都是可以访问的，当应用访问一个逻辑Page，而在对应的物理内存中并不存在的时候，这时候就发生了一次Page fault。当Page fault发生的时候，会中断当前的程序，在物理内存中寻找一个可用的Page，然后从磁盘中读取数据到物理内存，接着继续执行当前程序。 Dirty Page &amp; Clean Page1、如果一个Page可以从磁盘上重新生成，那么这个Page称为Clean Page2、如果一个Page包含了进程相关信息，那么这个Page称为Dirty Page像代码段这种只读的Page就是Clean Page。而像数据段(_DATA)这种读写的Page，当写数据发生的时候，会触发COW(Copy on write)，也就是写时复制，Page会被标记成Dirty，同时会被复制。 启动过程 加载动态库 dyld会首先读取mach-o文件的Header和load commands。接着就知道了这个可执行文件依赖的动态库。例如加载动态库A到内存，接着检查A所依赖的动态库，就这样的递归加载，直到所有的动态库加载完毕。通常一个App所依赖的动态库在100-400个左右，其中大多数都是系统的动态库，它们会被缓存到dyld shared cache，这样读取的效率会很高。 Rebase &amp;&amp; Bind为什么要Rebase？ 有两种主要的技术来保证应用的安全：ASLR和Code Sign。 ASLR的全称是Address space layout randomization，翻译过来就是“地址空间布局随机化”。App被启动的时候，程序会被影射到逻辑的地址空间，这个逻辑的地址空间有一个起始地址，而ASLR技术使得这个起始地址是随机的。如果是固定的，那么黑客很容易就可以由起始地址+偏移量找到函数的地址。 Rebase 修正内部(指向当前mach-o文件)的指针指向 Bind 修正外部指针指向 Objective CObjective C是动态语言，所以在执行main函数之前，需要把类的信息注册到一个全局的Table中。同时，Objective C支持Category，在初始化的时候，也会把Category中的方法注册到对应的类中，同时会唯一Selector，这也是为什么当你的Cagegory实现了类中同名的方法后，类中的方法会被覆盖。 另外，由于iOS开发时基于Cocoa Touch的，所以绝大多数的类起始都是系统类，所以大多数的Runtime初始化起始在Rebase和Bind中已经完成。 Initializers接下来就是必要的初始化部分了，主要包括几部分： +load方法。C／C++静态初始化对象和标记为attribute(constructor)的方法这里要提一点的就是，+load方法已经被弃用了，如果你用Swift开发，你会发现根本无法去写这样一个方法，官方的建议是实用initialize。区别就是，load是在类装载的时候执行，而initialize是在类第一次收到message前调用。 Main函数之后从main函数开始执行，到你的第一个界面显示，这期间一般会做哪些事情。 执行AppDelegate的代理方法，主要是didFinishLaunchingWithOptions 初始化Window，初始化基础的ViewController结构(一般是UINavigationController+UITabViewController) 获取数据(Local DB／Network)，展示给用户。 总结不同的App在启动的时候做的事情往往不同，但是优化起来的核心思想无非就两个： 能延迟执行的就延迟执行。比如SDK的初始化，界面的创建。不能延迟执行的，尽量放到后台执行。比如数据读取，原始JSON数据转对象，日志发送。Main函数之前 Main函数之前是iOS系统的工作，所以这部分的优化往往更具有通用性。 dylibs启动的第一步是加载动态库，加载系统的动态库使很快的，因为可以缓存，而加载内嵌的动态库速度较慢。所以，提高这一步的效率的关键是：减少动态库的数量。 合并动态库，比如公司内部由私有Pod建立了如下动态库：XXTableView, XXHUD, XXLabel，强烈建议合并成一个XXUIKit来提高加载速度。 Rebase &amp; Bind &amp; Objective C RuntimeRebase和Bind都是为了解决指针引用的问题。对于Objective C开发来说，主要的时间消耗在Class/Method的符号加载上，所以常见的优化方案是： 减少__DATA段中的指针数量。合并Category和功能类似的类。比如：UIView+Frame,UIView+AutoLayout…合并为一个删除无用的方法和类。多用Swift Structs，因为Swfit Structs是静态分发的。感兴趣的同学可以看看我之前这篇文章：《Swift进阶之内存模型和方法调度》 Initializers通常，我们会在+load方法中进行method-swizzling，这也是Nshipster推荐的方式。 用initialize替代load。不少同学喜欢用method-swizzling来实现AOP去做日志统计等内容，强烈建议改为在initialize进行初始化。减少atribute((constructor))的使用，而是在第一次访问的时候才用dispatch_once等方式初始化。不要创建线程使用Swfit重写代码。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio平台下无线调试]]></title>
    <url>%2F2018%2F06%2F11%2Fandroid%2FAndroid%20Studio%E5%B9%B3%E5%8F%B0%E4%B8%8B%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Android Studio平台下无线调试]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-spring]]></title>
    <url>%2F2018%2F06%2F11%2Fjava%2Fjava-spring%2F</url>
    <content type="text"><![CDATA[spring框架1234Spring是一个开放源代码的设计层面框架，他解决的是业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用。Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson创建。简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架。 下载和安装Spring请按如下步骤进行。（1）登录站点，下载Spring的最新稳定版本。最新版本为spring-framework-5.0.建议下载spring-framework-spring-framework-4.0.0.M2-dist这个压缩包不仅包含Spring的开发包，而且包含Spring编译和运行所依赖的第三方类库。解压缩下载到的压缩包，解压缩后的文件夹应用如下几个文件夹。dist：该文件夹下放Spring的jar包，通常只需要Spring.jar文件即可。该文件夹下还有一些类似spring－Xxx.jar的压缩包， 这些压缩包是spring.jar压缩包的子模块压缩包。除非确定整个J2EE应用只需要使用Spring的某一方面时，才考虑使用这种分模块压缩包。通常建议使用Spring.jardocs：该文件夹下包含spring的相关文档、开发指南及API参考文档。lib：该文件夹下包含spring编译和运行所依赖的第三方类库，该路径下的类库并不是 spring必需的，但如果需要使用第三方类库的支持，这里的类库就是必需要的。samples：该文件夹下包含Spring的几个简单例子，可作为Spring入门学习的案例。src：该文件夹下包含Spring的全部源文件，如果开发过程中有地方无法把握，可以参考该源文件，了解底层实现。springspringtest：该文件夹下包含Spring的测试示例。tiger：该路径下存放关于JDK的相关内容解压缩后的文件夹下，还包含一些关于Spring的License和项目相关文件（2）将spring.jar复制到项目的CLASSPATH路径下，对于Web应用，将spring.jar文件复制到WEB-INF/lib路径下，该应用即可以利用Spring框架了。（3）通常Spring的框架还依赖于其他一些jar文件，因此还须将lib下对应的包复制到WEB-INF/lib路径下，具体要复制哪些jar文件，取决于应用所需要使用的项目。通常需要复制cglib，dom4j，jakarta-commons，log4j等文件夹下的jar文件。（4）为了编译java文件，可以找到Spring的基础类，将Spring.jar文件的路径添加到环境变量CLASSPATH中。当然，也可以使用ANT工具，但无须添加环境变量。如果使用Eclipse或者NetBeans等IDE时，也不需要设置环境变量。 Spring MVC传统的web架构的view 表现层使用struts作为表现层。但是如果试用下spring自带的MVC，会发现spring 在一般场合完全可以取代struts。从某些角度来说，spring的mvc设计的更加合理，有兴趣的话不妨尝试下单个的spring的MVC。 w3Cschool-spring学习 Spring Boot 是什么？1Spring Boot 的目的是提供一组工具，以便快速构建容易配置的 Spring 应用程序。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Web应用程序的推荐目录结构]]></title>
    <url>%2F2018%2F06%2F11%2Fjava%2FJava%20Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A8%E8%8D%90%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Java Web应用程序的推荐目录结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152├── pom.xml└── src ├── main │ ├── java │ │ └── mygroup │ │ ├── controller │ │ │ ├── HomeController.java │ │ │ └── PersonController.java │ │ ├── dao │ │ │ └── PersonDao.java │ │ └── model │ │ └── Person.java │ ├── resources │ │ ├── db.properties │ │ ├── log4j.xml │ │ └── META-INF │ │ └── persistence.xml │ └── webapp │ ├── index.html │ ├── META-INF │ │ ├── context.xml │ │ └── MANIFEST.MF │ ├── resources │ │ └── css │ │ └── screen.css │ └── WEB-INF │ ├── spring │ │ ├── app │ │ │ ├── controllers.xml │ │ │ └── servlet-context.xml │ │ ├── db.xml │ │ └── root-context.xml │ ├── views │ │ ├── edit.jsp │ │ ├── home.jsp │ │ └── list.jsp │ └── web.xml └── test ├── java │ └── mygroup │ ├── controller │ │ ├── DataInitializer.java │ │ ├── HomeControllerTest.java │ │ └── PersonControllerTest.java │ └── dao │ └── PersonDaoTest.java └── resources ├── db.properties ├── log4j.xml ├── test-context.xml └── test-db.xml Java Web应用程序的推荐目录结构Java Web 项目目录规范用IntelliJ idea 创建 springMVC 的Maven 项目]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java Web应用程序的推荐目录结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[商丘历史变迁]]></title>
    <url>%2F2018%2F06%2F11%2F%E6%88%91%E7%9A%84%E6%97%A5%E5%B8%B8%E5%85%B4%E8%B6%A3%2F%E5%95%86%E4%B8%98%E5%8E%86%E5%8F%B2%E5%8F%98%E8%BF%81%2F</url>
    <content type="text"><![CDATA[三皇五帝时期 旧石器时代，三皇之首的燧人氏出生于商丘并在这一带建立燧明国8500年前，栗陆氏建都于栗（今商丘夏邑县）6000年前，炎帝朱襄氏建都于朱（今商丘柘城县）。葛天氏建都于葛（今商丘宁陵县）。4500年前，颛顼由穷桑迁都于商丘（今商丘睢阳区）。帝喾高辛氏出生并封于高辛（今商丘高辛镇），成为天下共主后，定都亳（今商丘谷熟镇）。帝喾死后，长子帝挚受禅接帝位，在位九年，因未能妥善管理国家，挚禅位于唐尧，帝尧封挚于高辛。帝尧时代，商丘为后羿的封地。帝舜时代，帝喾之（睢阳区）帝喾陵（睢阳区）帝喾陵子契（阏伯）辅佐禹治水有功，被虞舜封于商（今睢阳区）做火正，为商族人的始祖，深受人民的爱戴，故人们尊他为“火神”阏伯死后葬于封地，由于阏伯的封号为“商”，他的墓冢被称为“商丘”]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 基础]]></title>
    <url>%2F2018%2F06%2F11%2Fjava%2Fjava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[背景]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 博客框架]]></title>
    <url>%2F2018%2F06%2F11%2Fother%2FHexo%2F</url>
    <content type="text"><![CDATA[什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装 Hexo1$ npm install -g hexo-cli 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 1234567891011121314151617181920package.json&#123; &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^3.0.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.0&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.0&quot;, &quot;hexo-generator-index&quot;: &quot;^0.1.0&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.1.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.1.0&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.2.4&quot;, &quot;hexo-server&quot;: &quot;^0.1.2&quot; &#125;&#125; _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 themes 主题 文件夹。Hexo 会根据主题来生成静态页面。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 重要的几个指令了解更多 详见指令 信息 初始化新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站 1$ hexo init [folder] server 启动服务器。默认情况下，访问网址为： http://localhost:4000/。 1$ hexo server generate 生成静态文件。 1$ hexo generate deploy 部署网站。 1$ hexo deploy clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 1$ hexo clean 资源文件夹 资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于1![](/images/image.jpg) 的方法访问它们。 部署 Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。详见网站 信息]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>博客框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 博客框架添加搜索]]></title>
    <url>%2F2018%2F06%2F11%2Fother%2FHexo%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[用Hexo提供的Local Search,原理是通过hexo-generator-search插件在本地生成一个search.xml文件，搜索的时候从这个文件中根据关键字检索出相应的链接。 安装步骤安装 hexo-generator-search在站点的根目录下执行以下命令： 1$ npm install hexo-generator-search --save 安装 hexo-generator-searchdb在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 启用搜索 编辑 站点配置文件_config.yml，新增以下内容到任意位置： search: path: search.xml field: post format: html limit: 10000 修改主题配置文件 我的路径：/blog/themes/next下的_config.yml文件，进行编辑。 local_search: enable: true 最后部署到github、coding，打开网页就可以看到搜索功能了。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>博客框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 编辑器语法指南]]></title>
    <url>%2F2018%2F06%2F11%2Fother%2FMarkdown%2F</url>
    <content type="text"><![CDATA[Markdown 编辑器语法指南 MacDown 代码高亮如果你只想高亮语句中的某个函数名或关键字，可以使用 function_name() 实现通常编辑器根据代码片段适配合适的高亮方法，但你也可以用 以下方式 包裹一段代码，并指定一种语言 123$(document).ready(function () &#123; alert('hello world');&#125;); 支持的语言：1c, abnf, accesslog, actionscript, ada, apache, applescript, arduino, armasm, asciidoc, aspectj, autohotkey, autoit, avrasm, awk, axapta, bash, basic, bnf, brainfuck, cal, capnproto, ceylon, clean, clojure, clojure-repl, cmake, coffeescript, coq, cos, cpp, crmsh, crystal, cs, csp, css, d, dart, delphi, diff, django, dns, dockerfile, dos, dsconfig, dts, dust, ebnf, elixir, elm, erb, erlang, erlang-repl, excel, fix, flix, fortran, fsharp, gams, gauss, gcode, gherkin, glsl, go, golo, gradle, groovy, haml, handlebars, haskell, haxe, hsp, htmlbars, http, hy, inform7, ini, irpf90, java, javascript, json, julia, kotlin, lasso, ldif, leaf, less, lisp, livecodeserver, livescript, llvm, lsl, lua, makefile, markdown, mathematica, matlab, maxima, mel, mercury, mipsasm, mizar, mojolicious, monkey, moonscript, n1ql, nginx, nimrod, nix, nsis, objectivec, ocaml, openscad, oxygene, parser3, perl, pf, php, pony, powershell, processing, profile, prolog, protobuf, puppet, purebasic, python, q, qml, r, rib, roboconf, rsl, ruby, ruleslanguage, rust, scala, scheme, scilab, scss, smali, smalltalk, sml, sqf, sql, stan, stata, step21, stylus, subunit, swift, taggerscript, tap, tcl, tex, thrift, tp, twig, typescript, vala, vbnet, vbscript, vbscript-html, verilog, vhdl, vim, x86asm, xl, xml, xquery, yaml, zephir markdown12345678910111213141516&lt;b&gt; Markdown 在此处同样适用，如 *加粗* &lt;/b&gt;- 列表文本前使用 [减号+空格]+ 列表文本前使用 [加号+空格]* 列表文本前使用 [星号+空格]&gt; 引用文本前使用 [大于号+空格]&gt; 折行可以不加，新起一行都要加上哦&gt; &gt; &gt; 最外层引用&gt; &gt; 多一个 &gt; 嵌套一层引用&gt; &gt; &gt; 可以嵌套很多层![图片名称](http://图片网址) 分隔符 如果你有写分割线的习惯，可以新起一行输入三个减号-。前后都有段落时，请空出一行： 12345前面的段落---后面的段落]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>md</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OmniGraffle 五步绘制流程图]]></title>
    <url>%2F2018%2F06%2F11%2Fother%2FOmniGraffle%20%E4%BA%94%E6%AD%A5%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[OmniGraffle 五步绘制流程图 OmniGraffle 基础入门（一）：从工具栏开始]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>OmniGraffle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终极 Shell]]></title>
    <url>%2F2018%2F06%2F11%2Fother%2F%E7%BB%88%E6%9E%81%20Shell%2F</url>
    <content type="text"><![CDATA[方案名称在开始今天的 MacTalk 之前，先问两个问题吧：来自：https://zhuanlan.zhihu.com/p/19556676?columnSlug=mactalk 相对于其他系统，Mac 的主要优势是什么？你们平时用哪种 Shell？ 1234567891011121314151617181920212223242526272829303132333435……第一个童靴可以坐下了，Mac 的最大优势是 GUI 和命令行的完美结合，不要把所有注意力放在 Mac 性感的腰身和明媚的显示屏上好吧，这不是妹纸！第二个童靴你可以出去面壁了，讲了这么多期 MacTalk 你告诉我还在用 Windows 的 cmd， 你让 Mac 君情何以堪？哪怕你就说在用 Linux 的 Bash 我也就原谅你了，踢飞！上次在「如何学习一门编程语言」里提到了 Shell，也有读者问到 Shell 的问题，所以这次给大家说说 Shell 的事。我在「趣谈个人建站」里介绍过一点 Shell，自己的东西借用下不丢人，把扯淡的拿掉，干货留下，就是如下内容：Shell是Linux/Unix的一个外壳，你理解成衣服也行。它负责外界与Linux内核的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后再把结果返回用户或应用程序。Linux/Unix提供了很多种Shell，为毛要这么多Shell？难道用来炒着吃么？那我问你，你同类型的衣服怎么有那么多件？花色，质地还不一样。写程序比买衣服复杂多了，而且程序员往往负责把复杂的事情搞简单，简单的事情搞复杂。牛程序员看到不爽的Shell，就会自己重新写一套，慢慢形成了一些标准，常用的Shell有这么几种，sh、bash、csh等，想知道你的系统有几种shell，可以通过以下命令查看：cat /etc/shells显示如下：/bin/bash/bin/csh/bin/ksh/bin/sh/bin/tcsh/bin/zsh在 Linux 里执行这个命令和 Mac 略有不同，你会发现 Mac 多了一个 zsh，也就是说 OS X 系统预装了个 zsh，这是个神马 Shell 呢？目前常用的 Linux 系统和 OS X 系统的默认 Shell 都是 bash，但是真正强大的 Shell 是深藏不露的 zsh， 这货绝对是马车中的跑车，跑车中的飞行车，史称『终极 Shell』，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看 zsh 的配置指南，什么都不说转身就走了。直到有一天，国外有个穷极无聊的程序员开发出了一个能够让你快速上手的zsh项目，叫做「oh my zsh」，Github 网址是：https://github.com/robbyrussell/oh-my-zsh。这玩意就像「X天叫你学会 C++」系列，可以让你神功速成，而且是真的。好，下面我们看看如何安装、配置和使用 zsh。安装zsh如果你用 Mac，就可以直接看下一节如果你用 Redhat Linux，执行：sudo yum install zsh如果你用 Ubuntu Linux，执行：sudo apt-get install zsh如果你用 Windows……去洗洗睡吧。安装完成后设置当前用户使用 zsh：chsh -s /bin/zsh，根据提示输入当前用户的密码就可以了。安装oh my zsh首先安装 git，安装方式同上，把 zsh 换成 git 即可。安装「oh my zsh」可以自动安装也可以手动安装。自动安装：wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh手动安装：git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zshcp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc都不复杂，安装完成之后退出当前会话重新打开一个终端窗口，你就可以见到这个彩色的提示了：配置zsh 的配置主要集中在用户当前目录的.zshrc里，用 vim 或你喜欢的其他编辑器打开.zshrc，在最下面会发现这么一行字： Customize to your needs…123456789101112131415161718192021222324252627282930可以在此处定义自己的环境变量和别名，当然，oh my zsh 在安装时已经自动读取当前的环境变量并进行了设置，你可以继续追加其他环境变量。接下来进行别名的设置，我自己的部分配置如下：alias cls=&apos;clear&apos;alias ll=&apos;ls -l&apos;alias la=&apos;ls -a&apos;alias vi=&apos;vim&apos;alias javac=&quot;javac -J-Dfile.encoding=utf8&quot;alias grep=&quot;grep --color=auto&quot;alias -s html=mate # 在命令行直接输入后缀为 html 的文件名，会在 TextMate 中打开alias -s rb=mate # 在命令行直接输入 ruby 文件，会在 TextMate 中打开alias -s py=vi # 在命令行直接输入 python 文件，会用 vim 中打开，以下类似alias -s js=vialias -s c=vialias -s java=vialias -s txt=vialias -s gz=&apos;tar -xzvf&apos;alias -s tgz=&apos;tar -xzvf&apos;alias -s zip=&apos;unzip&apos;alias -s bz2=&apos;tar -xjvf&apos;zsh 的牛粪之处在于不仅可以设置通用别名，还能针对文件类型设置对应的打开程序，比如：alias -s html=mate，意思就是你在命令行输入 hello.html，zsh会为你自动打开 TextMat 并读取 hello.html； alias -s gz=&apos;tar -xzvf&apos;，表示自动解压后缀为 gz 的压缩包。总之，只有想不到，木有做不到。设置完环境变量和别名之后，基本上就可以用了，如果你是个主题控，还可以玩玩 zsh 的主题。在 .zshrc 里找到ZSH_THEME，就可以设置主题了，默认主题是：ZSH_THEME=”robbyrussell”oh my zsh 提供了数十种主题，相关文件在~/.oh-my-zsh/themes目录下，你可以随意选择，也可以编辑主题满足自己的变态需求，我采用了默认主题robbyrussell，不过做了一点小小的改动：PROMPT=&apos;%&#123;$fg_bold[red]%&#125;➜ %&#123;$fg_bold[green]%&#125;%p%&#123;$fg[cyan]%&#125;%d %&#123;$fg_bold[blue]%&#125;$(git_prompt_info)%&#123;$fg_bold[blue]%&#125;% %&#123;$reset_color%&#125;&gt;&apos;#PROMPT=&apos;%&#123;$fg_bold[red]%&#125;➜ %&#123;$fg_bold[green]%&#125;%p %&#123;$fg[cyan]%&#125;%c %&#123;$fg_bold[blue]%&#125;$(git_prompt_info)%&#123;$fg_bold[blue]%&#125; % %&#123;$reset_color%&#125;&apos;对照原来的版本，我把 c 改为 d，c 表示当前目录，d 表示绝对路径，另外在末尾增加了一个「 &gt; 」，改完之后的效果是这样的：大家可以尝试进行改造，也算个趣事。最后我们来说说插件。 插件oh my zsh 项目提供了完善的插件体系，相关的文件在~/.oh-my-zsh/plugins目录下，默认提供了100多种，大家可以根据自己的实际学习和工作环境采用，想了解每个插件的功能，只要打开相关目录下的 zsh 文件看一下就知道了。插件也是在.zshrc里配置，找到plugins关键字，你就可以加载自己的插件了，系统默认加载 git ，你可以在后面追加内容，如下：plugins=(git textmate ruby autojump osx mvn gradle)下面简单介绍几个： git：当你处于一个 git 受控的目录下时，Shell 会明确显示 「git」和 branch，如上图所示，另外对 git 很多命令进行了简化，例如 gco=’git checkout’、gd=’git diff’、gst=’git status’、g=’git’等等，熟练使用可以大大减少 git 的命令长度，命令内容可以参考~/.oh-my-zsh/plugins/git/git.plugin.zshtextmate：mr可以创建 ruby 的框架项目，tm finename 可以用 textmate 打开指定文件。osx：tab 增强，quick-look filename 可以直接预览文件，man-preview grep 可以生成 grep手册 的pdf 版本等。autojump：zsh 和 autojump 的组合形成了 zsh 下最强悍的插件，今天我们主要说说这货。 首先安装autojump，如果你用 Mac，可以使用 brew 安装：brew install autojump如果是 Linux，去下载 autojump 的最新版本，比如：wget https://github.com/downloads/joelthelion/autojump/autojump_v21.1.2.tar.gz解压缩后进入目录，执行./install.sh最后把以下代码加入.zshrc：[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh至此，安装、配置、插件三位一体，终极 Shell 全面登场。退出终端会话重新登录，开始感受 zsh 的训疾如风！ 使用 zsh兼容 bash，原来使用 bash 的兄弟切换过来毫无压力，该咋用咋用。强大的历史纪录功能，输入 grep 然后用上下箭头可以翻阅你执行的所有 grep 命令。智能拼写纠正，输入gtep mactalk -R，系统会提示：zsh: correct ‘gtep’ to ‘grep’ [nyae]? 比妹纸贴心吧，她们向来都是让你猜的……各种补全：路径补全、命令补全，命令参数补全，插件内容补全等等。触发补全只需要按一下或两下 tab 键，补全项可以使用 ctrl+n/p/f/b上下左右切换。比如你想杀掉 java 的进程，只需要输入 kill java + tab键，如果只有一个 java 进程，zsh 会自动替换为进程的 pid，如果有多个则会出现选择项供你选择。ssh + 空格 + 两个tab键，zsh会列出所有访问过的主机和用户名进行补全智能跳转，安装了autojump之后，zsh 会自动记录你访问过的目录，通过 j + 目录名 可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过hadoop-1.0.0目录，输入j hado 即可正确跳转。j –stat 可以看你的历史路径库。目录浏览和跳转：输入 d，即可列出你在这个会话里访问的目录列表，输入列表前的序号，即可直接跳转。在当前目录下输入 .. 或 … ，或直接输入当前目录名都可以跳转，你甚至不再需要输入 cd 命令了。通配符搜索：ls -l **/.sh，可以递归显示当前目录下的 shell 文件，文件少时可以代替 find，文件太多就歇菜了。更强的别名：请参考配置一节。插件支持：请参考插件一节。 看完这篇文章，你就知道，zsh一出，无人再与争锋！终极二字不是盖的。如果你是个正在使用 shell程序员，如果你依然准备使用 bash，那就去面壁和忏悔吧，别说你订阅过 MacTalk！感谢那位开发了 oh my zsh 的无聊程序员，他可能没有因此收获物质上的利益，但是他的代码提升了无数程序员的效率，节省了大量的时间，我们说，程序员改变世界！MacTalk 写的多了，朋友和家人都不太理解，这玩意赚不了钱争不了名，写来何用？我想，能够学习、编码、写作，并做出一点帮助别人的东西，总好过炒股炒房的价值吧……]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac端本地服务搭建]]></title>
    <url>%2F2018%2F06%2F11%2Fother%2FMac%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[方案名称Mac 系统 - 启用 Mac 本地 Web 服务器关键字 Mac 系统 \ Web 服务器 需求场景 局域网搭建 Web 服务器测试环境参考链接 简书 - Mac OS X 启用 Web 服务器(推荐)详细内容 https://www.jianshu.com/p/d006a34a343f 启动 Apache终端输入$ sudo apachectl start可启动 Apache，打开浏览器，输入 http://localhost/ 看到如下页面证明本地 Web 服务器启动成功 可启动 Apache，默认站点的根目录为系统级根目录/Library/WebServer/Documents更多信息，可参考 简书 - Mac OS X 启用 Web 服务器(推荐) 创建用户级根目录 启动 PHP 安装 MySQL 开启 HTTPS https://github.com/viktyz/iosnotebook/blob/master/Notes/Note_00222_20170601.md 关闭和重启Mac OS 终端起动、关闭、重启apache的方 Mac OS 终端起动、关闭、重启apache的方法 打开终端重启apache：sudo /usr/sbin/apachectl restart关闭apache：sudo /usr/sbin/apachectl stop开启apache：sudo /usr/sbin/apachectl start Mac下如何修改apache根目录Mac下如何修改apache根目录]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>启动本地服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat]]></title>
    <url>%2F2018%2F06%2F11%2Fother%2Ftomcat%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Tomcat的目录结构详细介绍 运行切换到tomcat所在的目录在终端执行如下命令：bash bin/startup.sh 用来启动tomcat 然后直接localhost:8080/ 就可以访问了 文件放置webapps目录用来存放应用程序，当tomcat启动时会去加载webapps目录下的应用程序。可以以文件夹、war包、jar包的形式发布应用 修改http访问端口（默认为8080端口），将8080修改为tomcat不在使用的端口号1、安装目录下的conf子目录中的server.xml文件 修改位置如下： 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 2、然后在关闭和重启操作 bash bin/shutdown.sh 用来关闭tomcatbash bin/startup.sh 用来启动tomcat 启动tomcat 服务报 The file is absent or does not have execute permission1、在linu上部署好tomcat后，准备启动时报错： Cannot find bin/catalina.shThe file is absent or does not have execute permission This file is needed to run this program 2、解决办法： 对启动脚本添加执行权限 chmod 777 *.sh]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树]]></title>
    <url>%2F2018%2F06%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%2F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[定义：n个节点构成的有序集合。1、顺序查找2、二分查找 二分查找判定树，ASL，3、树4、二叉树 第一章 绪论（a）计算（b）计算模型（c）大O记号（d）算法分析（e）迭代与递归（xc）动态规划第二章 向量（a）接口与实现（b）可扩充向量（c）无序向量（d1）有序向量：唯一化（d2）有序向量：二分查找（d3）有序向量：Fibonacci查找（d4）有序向量：二分查找（改进）（d5）有序向量：插值查找（e）起泡排序（f）归并排序第三章 列表（a）接口与实现（b）无序列表（c）有序列表（d）选择排序（e）插入排序第四章 栈与队列（a）栈接口与实现（c1）栈应用：进制转换（c2）栈应用：括号匹配（c3）栈应用：栈混洗（c4）栈应用：中缀表达式求值（c5）栈应用：逆波兰表达式（d）队列接口与实现第五章 二叉树（a）树（b）树的表示（c）二叉树（d）二叉树实现（e1）先序遍历（e2）中序遍历（e4）层次遍历（e5）重构第六章 图（a）概述（b1）邻接矩阵（c）广度优先搜索（d）深度优先搜索第七章 二叉搜索树（a）概述（b1）BST：查找（b2）BST：插入（b3）BST：删除（c）平衡与等价（d1）AVL树：重平衡（d2）AVL树：插入（d3）AVL树：删除（d4）AVL树：(3+4)-重构第八章 高级搜索树(a1)伸展树：逐层伸展(a2)伸展树：双层伸展(a3)伸展树：算法实现(b1)B-树：动机(b2)B-树：结构(b3)B-树：查找(b4)B-树： 插入(b5)B-树： 删除(xa1)红黑树：动机(xa2)红黑树：结构(xa3)红黑树：插入(xa4)红黑树：删除]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二十四节气]]></title>
    <url>%2F2018%2F06%2F11%2F%E6%88%91%E7%9A%84%E6%97%A5%E5%B8%B8%E5%85%B4%E8%B6%A3%2F%E4%B8%AD%E5%9B%BD%E8%8A%82%E6%B0%94%2F</url>
    <content type="text"><![CDATA[二十四节气 二十四节气是根据地球在黄道（即地球绕太阳公转的轨道）上的位置来划分的。视太阳从春分点（黄经零度，此刻太阳垂直照射赤道）出发，每前进15度为一个节气；运行一周又回到春分点，为一回归年，合360度，因此分为24个节气。 节与气一年有二十四个节气，计十二个节和十二个气。即一个月之内有一节一气，每两节气相距，平均约三十天又十分之四，而阴历每月之日数．则为二十九天半，故约每三十四个月，必遇有两月仅有节而无气、及有气而无节者。有节无气之月，即农历之闰月，有气无节之月不为闰月，兹将节气与农历月份关系表列于后： 季月节气表季春夏秋冬月正月二月三月四月五月六月七月八月九月十月冬月腊月节立春惊蛰清明立夏芒种小暑立秋白露寒露立冬大雪小寒气雨水春分谷雨小满夏至大暑处暑秋分霜降小雪冬至大寒 二十四节气歌春雨惊春清谷天，夏满芒夏暑相连。秋处露秋寒霜降，冬雪雪冬小大寒。上半年逢六廿一，下半年逢八廿三。每月两节不变更，最多相差一两天。 九九歌一九二九不出手；三九四九冰上走； 五九六九沿河看柳；七九河开八九燕来； 九九加一九，耕牛遍地走； 我国阴历有“九九”的说法，用来计算时令。计算的方法是从冬天的冬至日算起，第一个九天叫“一九”。第二个九天叫“二九”，依此类推，一直到“九九”。即第九个九天，这时冬天已过完，春天来到了。 三伏伏日宜吃面，北方有句俚语，叫做“头伏饺子二伏面，三伏烙饼摊鸡蛋”。头伏饺子二伏面百科 二十四节气百科]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web页面打开APP]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%89%8D%E7%AB%AF%2F%E7%94%A8%E4%BA%8E%E5%9C%A8safari%E8%B7%B3%E8%BD%AC%E5%88%B0APP%E7%9A%84web%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[在WXApp上设置一个URL Schemes123为了能让别的App(包括我们刚才创建的MyApp)能够打开 OpenTest，我们需要为app添加一个URL Schemes。步骤：选中app工程-&gt;Info-&gt;URL Types-&gt;点击“+”-&gt;在URL Schemes栏填上 OpenTest 打开APP xxx.html 可以保存一下页面为.html 放在本地服务Document目录下 快速启动 12345678910111213141516171819202122232425262728293031323334&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta content="text/html; charset=utf-8" http-equiv="Content-Type"&gt; &lt;meta name="HandheldFriendly" content="true"/&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"&gt; &lt;script type="text/javascript"&gt; function open_win() &#123; window.open("OpenTest") // window.open("http://www.baidu.com") &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div style="width:100%;height: 100%;background: white; position: absolute;"&gt; &lt;!-- 方法一 --&gt; &lt;a style="margin-top:200px; width:100%;color:#666; font-size:32px; text-align: center ;display:inline-block;" href="OpenTest" target="_blank"&gt;打开OpenTest App页面&lt;/a&gt; &lt;/div&gt; &lt;!-- OpenTest --&gt; &lt;!-- 方法二跳转有点问题 --&gt; &lt;!-- &lt;input type=button style="width:250px; height=200px;" size="60" value="dsl open 打开" onclick="open_win()" /&gt; --&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>web页面打开APP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC，MVP 和 MVVM]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%89%8D%E7%AB%AF%2FMVC%EF%BC%8CMVP%20%E5%92%8C%20MVVM%20%2F</url>
    <content type="text"><![CDATA[复杂的软件必须有清晰合理的架构，否则无法开发和维护。MVC（Model-View-Controller）是最常见的软件架构之一，业界有着广泛应用。它本身很容易理解，但是要讲清楚，它与衍生的 MVP 和 MVVM 架构的区别就不容易了。昨天晚上，我读了《Scaling Isomorphic Javascript Code》，突然意识到，它们的区别非常简单。我用几段话，就可以说清。 MVCMVC模式的意思是，软件可以分成三个部分。 123* 视图（View）：用户界面。* 控制器（Controller）：业务逻辑* 模型（Model）：数据保存 各部分之间的通信方式如下。 View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈所有通信都是单向的。互动模式 接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller。 另一种是直接通过controller接受指令。 实例：Backbone实际项目往往采用更灵活的方式，以 Backbone.js 为例。 用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。 用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。 Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器） 。MVP MVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。 各部分之间的通信，都是双向的。 View 与 Model 不发生联系，都通过 Presenter 传递。 View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。MVVM MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。 唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。Angular 和 Ember 都采用这种模式。来自]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>MVC，MVP 和 MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[weex 开发坑点]]></title>
    <url>%2F2018%2F06%2F11%2Fvue%20%26%20weex%2Fweex%20%E5%9D%91%E7%82%B9%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940410、div 执行v-for循环的时候 要设置动态宽 自动撑满在iOS上有问题&lt;div v-for="(itemProduct,index) in productList" :style="&#123;height:sliderHeight,width:brandItemBgWidth&#125;" style="align-items: center;justify-content: center;"&gt;1、&lt;text&gt;aaa&lt;/text&gt; 该标签一定要写在一行否则native展示不对2、作为子组件里面的数据源一定要 这样写data: function () &#123; &#125; 必须加上function 不能做省略3、引入组件或者工具类 import PromotionWishLampItemView from './PromotionWishLampItemView.vue’ import Util from './PromotionUtil.js'4、引入的子组件要注册export default &#123; components: &#123; PromotionWishLampItemView &#125;,&#125;5、控件属性进行双向绑定用v-bind 缩写是冒号 :6、例如生命周期函数created、mounted和methods是并列的函数体，methods存放自定义函数7、 foreach不支持直接break// _wishLamps.forEach(function (item, index) &#123;////// foreach不支持直接break// &#125;);8、给某个对象添加属性并赋值的方式 if (typeof item.itemStyle == 'undefined') &#123; console.log('注册中 ====='); //全局注册 Vue.set(item, "itemStyle", "1"); &#125;9、数组剪切前四个（n个）的方案 _proList.slice(0, 4);10、数组添加对象的方式 _this.productList.push(wishLampDict);11、css style双向绑定要用花括号 :style="&#123;height:brandItemCurveHeight,width:brandItemWidth&#125;”12、json转化成能打印的字符串var str = JSON.stringify(result);console.log('qryExclusiveDiscount-backData:' + str);13、通过某个比例scale计算字体大小 如果不是整形在android上显示有问题 this.contentFontSize = Math.round(26 * scale);14、通过某个比例scale计算字体大小 如果不是整形在android上显示有问题 通过向上取整显示个别有问题通过向下取整 Math.floor]]></content>
      <categories>
        <category>weex</category>
      </categories>
      <tags>
        <tag>weex 坑点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表用顺序和链表来实现方式]]></title>
    <url>%2F2018%2F06%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%2F%E7%BA%BF%E6%80%A7%E8%A1%A8(%E6%95%B0%E7%BB%84%E6%88%96%E8%80%85%E9%93%BE%E8%A1%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0)%2F</url>
    <content type="text"><![CDATA[线性表：是最基本、最简单、也是最常用的一种数据结构。线性表（linear list）是数据结构的一种，一个线性表是n个具有相同特性的数据元素的有限序列。 顺序存储实现通常用到的比如：数组。 利用数组的连续存储空间顺序存放线性表的各元素。 顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，称为线性表的顺序存储结构或顺序映像（sequential mapping）。它以“物理位置相邻”来表示线性表中数据元素间的逻辑关系，可随机存取表中任一元素。 链式存储实现不需要逻辑上相邻的两个元素物理上也相邻，通过“链”建立起数据元素之间的逻辑关系。 插入、删除不需要移动数据元素，需要修改“链”。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线性表顺序和链存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android学习(2014、11、14)]]></title>
    <url>%2F2018%2F06%2F11%2Fandroid%2Fandroid%E5%AD%A6%E4%B9%A0(2014-11-14)%2F</url>
    <content type="text"><![CDATA[java中的匿名内部类总结匿名内部类也就是没有名字的内部类正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口(只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现最常用的情况就是在多线程的实现上，因为要实现多线程必须继承Thread类或是继承Runnable接口) sample1：Thread t = new Thread() { public void run() { for (int i = 1; i &lt;= 5; i++) { System.out.print(i + " "); } } }; t.start(); sample2：Runnable r = new Runnable() { public void run() { for (int i = 1; i &lt;= 5; i++) { System.out.print(i + " "); } } }; Thread t = new Thread(r); t.start(); Android中常常使用shape来定义控件的一些显示属性(比如：button，cell的backround) http://kofi1122.blog.51cto.com/2815761/521605 &lt;shape&gt; &lt;!-- 实心 --&gt; &lt;solid android:color="#ff9d77"/&gt; &lt;!-- 渐变 --&gt; &lt;gradient android:startColor="#ff8c00" android:endColor="#FFFFFF" android:angle="270" /&gt; &lt;!-- 描边 --&gt; &lt;stroke android:width="2dp" android:color="#dcdcdc" /&gt; &lt;!-- 圆角 --&gt; &lt;corners android:radius="2dp" /&gt; &lt;padding android:left="10dp" android:top="10dp" android:right="10dp" android:bottom="10dp" /&gt; &lt;/shape&gt; solid：实心，就是填充的意思android:color指定填充的颜色gradient：渐变android:startColor和android:endColor分别为起始和结束颜色，ndroid:angle是渐变角度，必须为45的整数倍。另外渐变默认的模式为android:type=”linear”，即线性渐变，可以指定渐变为径向渐变，android:type=”radial”，径向渐变需要指定半径 android:gradientRadius=”50”。stroke：描边android:width=”2dp” 描边的宽度，android:color 描边的颜色。我们还可以把描边弄成虚线的形式，设置方式为：android:dashWidth=”5dp”android:dashGap=”3dp”其中android:dashWidth表示’-‘这样一个横线的宽度，android:dashGap表示之间隔开的距离。 SharedPreferences的使用存：SharedPreferences settings = getSharedPreferences(“SharedInstance”, 0); settings.edit().putString(“name”, editView.getText().toString()).commit();取： //获取一个 SharedPreferences 对象 SharedPreferences settings = getSharedPreferences(“SharedInstance”, 0); //取出保存的NAME，取出改字段名的值，不存在则创建默认为空 String name = settings.getString(“name”, “”); corners：圆角android:radius为角的弧度，值越大角越圆。我们还可以把四个角设定成不同的角度，方法为： &lt;corners android:topRightRadius="20dp" 右上角 android:bottomLeftRadius="20dp" 右下角 android:topLeftRadius="1dp" 左上角 android:bottomRightRadius="0dp" 左下角 /&gt; 这里有个地方需要注意，bottomLeftRadius是右下角，而不是左下角，这个有点郁闷，不过不影响使用，记得别搞错了就行。还有网上看到有人说设置成0dp无效，不过我在测试中发现是可以的，我用的是2.2，可能修复了这个问题吧，如果无效的话那就只能设成1dp了。padding：间隔这个就不用多说了，XML布局文件中经常用到。大体的就是这样，以下是一个使用的具体示例：用在Selector中作为Button的背景，分别定义了按钮的一般状态、获得焦点状态和按下时的状态，具体代码如下：使用地方： &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="TestShapeButton" android:background="@drawable/button_selector" /&gt;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android学习]]></title>
    <url>%2F2018%2F06%2F11%2Fandroid%2Fandroid%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Android 之 fill_parent 、wrap_content 、match_parent属性fill_parent 设置一个顶部布局或控件为fill_parent将强制性让它布满整个屏幕。wrap_content 设置一个视图的尺寸为wrap_content将强制性地使视图扩展以显示全部内容 在程序中输出日志, 使用 android.util.Log 类.该类提供了若干静态方法Log.v(String tag, String msg);Log.d(String tag, String msg);Log.i(String tag, String msg);Log.w(String tag, String msg);Log.e(String tag, String msg);分别对应 Verbose, Debug, Info, Warning,Error.tag是一个标识,可以是任意字符串,通常可以使用类名+方法名, 主要是用来在查看日志时提供一个筛选条件.程序运行后 并不会在 ide的控制台内输出任何信息.如果要后查看日志 请使用adb logcat 快捷键command + shift + f 格式化代码 ，option + / 提示，option + 上下键 移动某行代码，option + command + 上下键，option + command + s 弹出菜单功能页，Ctrl+1 快速修复(最经典的快捷键,就不用多说了) layout文件夹里新建xml命名必须都是小写 完成A跳转到B操作：要在AndroidMainifest.xml的文件里面&lt;activity android:name="com.example.sample1.新加入的类名字” android:label=“页面的标题” &gt; &lt;/activity&gt; AndroidManifest.xml是Android应用程序中最重要的文件之一。它是Android程序的全局配置文件，是每个 android程序中必须的文件。它位于我们开发的应用程序的根目录下，描述了package中的全局数据，包括package中暴露的组件 （activities, services, 等等），以及他们各自的实现类，各种能被处理的数据和启动位置等重要信息。 布局Layout管理布局 布局即是指Activity中组件的呈现方式，即组件大小、间距和对齐方式等。 Android提供了两种创建布局的方式： 1.在XML配置文件中声明（推荐）。 2.在程序中通过代码直接实例化布局及其组件。在Android中常见的布局方式：线性布局（LinearLayout）：按照垂直或者水平方向布局组件。 帧布局（FrameLayout）：组件从屏幕的左上角坐标布局组件。 表格布局（TableLayout）：按照行列方式布局组件。 相对布局（RelativeLayout）：相对其他组件的布局方式。 绝对布局（AbsoluteLayout）：按照绝对坐标来布局组件。（已废）。2、一个ListView通常有两个职责。（1）将数据填充到布局。（2）处理用户的选择点击等操作。第一点很好理解，ListView就是实现这个功能的。第二点也不难做到，在后面的学习中读者会发现，这非常简单。一个ListView的创建需要3个元素。（1）ListView中的每一列的View。（2）填入View的数据或者图片等。（3）连接数据与ListView的适配器。3、关于List的用法List l=new List(); 现在这样，如果你想放得是User类，就这样new: List l=new List (); 这样编译器就可以帮你监督，如果你往里面放其他类对象，就会报错咯。 当然好处就是你拿出来就是User类对象，不用再强制转换了。比如过去： User u=(User)l.get(1); 现在就可以： User u=l.get(1);4、ArrayList &amp;&amp; HashMap 的使用 ArrayList&lt;HashMap&lt;String,String&gt;&gt; list=new ArrayList&lt;HashMap&lt;String,String&gt;&gt;(); HashMap&lt;String,String&gt; map1= new HashMap&lt;String,String&gt;(); HashMap&lt;String,String&gt; map2= new HashMap&lt;String,String&gt;(); HashMap&lt;String,String&gt; map3= new HashMap&lt;String,String&gt;(); map1.put("user", "zhang"); map1.put("id", "192.168.0.0"); map2.put("user", "wang"); map2.put("id", "192.168.0.1"); list.add(map1); list.add(map2); list.add(map3); Log.v("ArrayList==HashMap===:", list.toString()); AlertDialog 的使用 Builder alertDialog = new AlertDialog.Builder(this); alertDialog.setTitle("标题");// 设置标题 alertDialog.setMessage("一个消息框");// 设置消息 alertDialog.setPositiveButton("确定", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { // toast 的用法 Toast.makeText(getApplicationContext(), "你选择了确定", Toast.LENGTH_SHORT).show(); } }); alertDialog.show(); Button 的使用: 通过具体的id 找到某个控件// 给按钮加上点击事件 clickMeButton.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { Log.v("click", "=======clickButton======="); // 跳转到SecondActivity页面 Intent intent = new Intent(); intent.setClass(MainActivity.this, SecondActivity.class); startActivity(intent); } }); dp是虚拟像素，在不同的像素密度的设备上会自动适配，比如:在320x480分辨率，像素密度为160,1dp=1px在480x800分辨率，像素密度为240,1dp=1.5px计算公式:1dp*像素密度/160 = 实际像素数px（像素）：屏幕上的点。dp（与密度无关的像素）：一种基于屏幕密度的抽象单位。在每英寸160点的显示器上，1dp = 1px。尽量使用dp作为空间大小单位，sp作为和文字相关大小单位]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android学习(2014、11、17)]]></title>
    <url>%2F2018%2F06%2F11%2Fandroid%2Fandroid%E5%AD%A6%E4%B9%A0(2014-11-17)%2F</url>
    <content type="text"><![CDATA[1、http://www.blogjava.net/action/articles/17339.html 快捷键大全2、dp、sp和px的区别看到有很多网友不太理解dp、sp和px的区别：现在这里介绍一下dp和sp。dp也就是dip。这个和sp基本类似。如果设置表示长度、高度等属性时可 以使用dp 或sp。但如果设置字体，需要使用sp。dp是与密度无关，sp除了与密度无关外，还与scale无关。如果屏幕密度为160，这时dp和sp和px是一 样的。1dp=1sp=1px，但如果使用px作单位，如果屏幕大小不变（假设还是3.2寸），而屏幕密度变成了320。那么原来TextView的宽度 设成160px，在密度为320的3.2寸屏幕里看要比在密度为160的3.2寸屏幕上看短了一半。但如果设置成160dp或160sp的话。系统会自动 将width属性值设置成320px的。也就是160 * 320 / 160。其中320 / 160可称为密度比例因子。也就是说，如果使用dp和sp，系统会根据屏幕密度的变化自动进行转换。 checkBox的使用12345678910111213CheckBox checkBox1 = (CheckBox)findViewById(R.id.checkBox1);checkBox1.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; // TODO Auto-generated method stub if(isChecked)&#123; Log.v("CheckBox","你选择了-" + buttonView.getText()); &#125;else&#123; Log.v("CheckBox","你取消选择了-"+ buttonView.getText()); &#125; &#125;&#125;); RadioGroup的使用1234567891011121314RadioGroup radioGroup = (RadioGroup) findViewById(R.id.radioGroup);radioGroup.setOnCheckedChangeListener(new OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(RadioGroup group, int checkedId) &#123; int radioButtonId = group.getCheckedRadioButtonId(); Log.v("RadioGroup", "onCheckedChanged==id=" + checkedId + radioButtonId); // 根据ID获取RadioButton的实例 RadioButton rb = (RadioButton) SecondActivity.this .findViewById(radioButtonId); // 更新文本内容，以符合选中项 textView1.setText("您的性别是：" + rb.getText()); &#125;&#125;); Bundle的使用12345678 Bundle bundle = new Bundle(); bundle.putString("city", "上海"); bundle.putString("name", "狗子"); bundle.putString("age", "12"); bundle.putString("gender", "男"); String name = bundle.getString("name"); Log.v("Bundle","bundle.string="+ bundle.toString()+"名字："+name);//bundle.string=Bundle[&#123;gender=男, age=12, city=上海, name=狗子&#125;]名字：狗子 Android RelativeLayout 属性// 相对于给定ID控件android:layout_above 将该控件的底部置于给定ID的控件之上;android:layout_below 将该控件的底部置于给定ID的控件之下;android:layout_toLeftOf 将该控件的右边缘与给定ID的控件左边缘对齐;android:layout_toRightOf 将该控件的左边缘与给定ID的控件右边缘对齐; android:layout_alignBaseline 将该控件的baseline与给定ID的baseline对齐;android:layout_alignTop 将该控件的顶部边缘与给定ID的顶部边缘对齐;android:layout_alignBottom 将该控件的底部边缘与给定ID的底部边缘对齐;android:layout_alignLeft 将该控件的左边缘与给定ID的左边缘对齐;android:layout_alignRight 将该控件的右边缘与给定ID的右边缘对齐;// 相对于父组件android:layout_alignParentTop 如果为true,将该控件的顶部与其父控件的顶部对齐;android:layout_alignParentBottom 如果为true,将该控件的底部与其父控件的底部对齐;android:layout_alignParentLeft 如果为true,将该控件的左部与其父控件的左部对齐;android:layout_alignParentRight 如果为true,将该控件的右部与其父控件的右部对齐;// 居中android:layout_centerHorizontal 如果为true,将该控件的置于水平居中;android:layout_centerVertical 如果为true,将该控件的置于垂直居中;android:layout_centerInParent 如果为true,将该控件的置于父控件的中央;// 指定移动像素android:layout_marginTop 上偏移的值;android:layout_marginBottom 下偏移的值;android:layout_marginLeft 左偏移的值;android:layout_marginRight 右偏移的值; 下拉列表框 Spinner的使用myTextView = (TextView) findViewById(R.id.TextView_city); mySpinner = (Spinner) findViewById(R.id.Spinner_city); adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_spinner_item, citys); // 为适配器设置下拉列表下拉时的菜单样式。 adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item); // 将适配器添加到下拉列表上 mySpinner.setAdapter(adapter); mySpinner.setOnItemSelectedListener(new OnItemSelectedListener() { @Override public void onItemSelected(AdapterView&lt;?&gt; parent, View view, int position, long id) { // TODO Auto-generated method stub myTextView.setText("您的选择是：" + adapter.getItem(position)); } @Override public void onNothingSelected(AdapterView&lt;?&gt; parent) { // TODO Auto-generated method stub // myTextView.setText("NONE"); // parent.setVisibility(View.VISIBLE); } }); 类名.this 的使用我们会用到一些内部类和匿名类。当在匿名类中用this时，这个this则指的是匿名类或内部类本身。这时如果我们要使用外部类的方法和变量的话，则应该加上外部类的类名。 GridView 使用方式GridView gridView = (GridView) findViewById(R.id.gridview); gridView.setAdapter(new ImageAdapter(this)); gridView.setOnItemClickListener(new OnItemClickListener() { @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) { // TODO Auto-generated method stub Toast.makeText(GridViewActivity.this, mThumbIds[position], Toast.LENGTH_LONG).show(); } }); 代码法设置背景颜色ImageView设置背景颜色ImageView.setBackgroundColor(android.graphics.Color.parseColor(“#ffffff”));ImageView.setBackgroundColor(Color.RED);ImageView.setBackgroundColor(Color.rgb(255, 0, 0)); Android广播机制BroadcastReceiver用于接收程序（包括用户开发的程序和系统内建的程序）所发出的Broadcast Intent，与应用程序启动Activity、Service相同的是，程序启动BroadcastReceiver也只需要两步。1）创建需要启动的BroadcastReceiver的Intent。2）调用Context的sendBroadcast()或sendOrderedBroadcast()方法来启动指定BroadcastReceiver。内部类的方式 注册{ myBroadCast = new MyBroadCast(); IntentFilter filter = new IntentFilter(); filter.addAction(ACTION_INTENT_TEST); registerReceiver(myBroadCast, filter); } 内部类实现public class MyBroadCast extends BroadcastReceiver { public MyBroadCast() { Log.v("BROADCAST_TAG", "myBroadCast"); } @Override public void onReceive(Context context, Intent intent) { // TODO 处理接收到得广播 Log.v("BROADCAST_TAG", "onReceive===1111111"); } } 发送广播Intent intent = new Intent(ThirdActivity.ACTION_INTENT_TEST); sendBroadcast(intent); 取消注册 java @Override protected void onDestroy() { super.onDestroy(); unregisterReceiver(myBroadCast); }]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android学习(2014、11、19)]]></title>
    <url>%2F2018%2F06%2F11%2Fandroid%2Fandroid%E5%AD%A6%E4%B9%A02014-11-19%2F</url>
    <content type="text"><![CDATA[1、fragment的使用Fragment必须是依存与Activity而存在的http://blog.csdn.net/lmj623565791/article/details/37970961找fragment的方法：LeftFragment fragment = (LeftFragment) getFragmentManager().findFragmentById(R.id.left_fragment);2、Java关键字final、static使用总结 一、final 根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。final类不能被继承，没有子类，final类中的方法默认是final的。final方法不能被子类的方法覆盖，但可以被继承。final成员变量表示常量，只能被赋值一次，赋值后值不再改变。final不能用于修饰构造方法。注意：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。1、final类 final类不能被继承，因此final类的成员方法没有机会被覆盖，默认都是final的。在设计类时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会载被扩展，那么就设计为final类。2、final方法如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。使用final方法的原因有二：第一、把方法锁定，防止任何继承类修改它的意义和实现。第二、高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。例如： 123456789101112131415161718192021222324252627282930public class Test1 &#123; public static void main(String[] args) &#123; // TODO 自动生成方法存根 &#125; public void f1() &#123; System.out.println("f1"); &#125; //无法被子类覆盖的方法 public final void f2() &#123; System.out.println("f2"); &#125; public void f3() &#123; System.out.println("f3"); &#125; private void f4() &#123; System.out.println("f4"); &#125; &#125; public class Test2 extends Test1 &#123; public void f1()&#123; System.out.println("Test1父类方法f1被覆盖!"); &#125; public static void main(String[] args) &#123; Test2 t=new Test2(); t.f1(); t.f2(); //调用从父类继承过来的final方法 t.f3(); //调用从父类继承过来的方法 //t.f4(); //调用失败，无法从父类继承获得 &#125; &#125; 3、final变量（常量） 用final修饰的成员变量表示常量，值一旦给定就无法改变！ final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。 从下面的例子中可以看出，一旦给final变量初值后，值就不能再改变了。 另外，final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。但是，final空白在final关键字final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package org.leizhimin; public class Test3 &#123; private final String S="final实例变量S"; private final int A=100; public final int B=90; public static final int C=80; private static final int D=70; public final int E; //final空白,必须在初始化对象的时候赋初值 public Test3(int x)&#123; E=x; &#125; /** * @param args */ public static void main(String[] args) &#123; Test3 t=new Test3(2); //t.A=101; //出错,final变量的值一旦给定就无法改变 //t.B=91; //出错,final变量的值一旦给定就无法改变 //t.C=81; //出错,final变量的值一旦给定就无法改变 //t.D=71; //出错,final变量的值一旦给定就无法改变 System.out.println(t.A); System.out.println(t.B); System.out.println(t.C); //不推荐用对象方式访问静态字段 System.out.println(t.D); //不推荐用对象方式访问静态字段 System.out.println(Test3.C); System.out.println(Test3.D); //System.out.println(Test3.E); //出错,因为E为final空白,依据不同对象值有所不同. System.out.println(t.E); Test3 t1=new Test3(3); System.out.println(t1.E); //final空白变量E依据对象的不同而不同 &#125; private void test()&#123; System.out.println(new Test3(1).A); System.out.println(Test3.C); System.out.println(Test3.D); &#125; public void test2()&#123; final int a; //final空白,在需要的时候才赋值 final int b=4; //局部常量--final用于局部变量的情形 final int c; //final空白,一直没有给赋值. a=3; //a=4; 出错,已经给赋过值了. //b=2; 出错,已经给赋过值了. &#125; &#125; ``` 4、final参数 当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值。 ``` javapublic class Test4 &#123; public static void main(String[] args) &#123; new Test4().f1(2); &#125; public void f1(final int i)&#123; //i++; //i是final类型的,值不允许改变的. System.out.print(i); &#125; &#125; 二、static static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量的概念。 被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。 用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成static变量的副本，而是类的所有实例共享同一个static变量。 static变量前可以有private修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用（当然也可以在非静态成员方法中使用–废话），但是不能在其他类中通过类名来直接引用，这一点很重要。实际上你需要搞明白，private是访问权限限定，static表示不要实例化就可以使用，这样就容易理解多了。static前面加上其它访问权限关键字的效果也以此类推。 static修饰的成员变量和成员方法习惯上称为静态变量和静态方法，可以直接通过类名来访问，访问语法为：类名.静态方法名(参数列表…)类名.静态变量名 用static修饰的代码块表示静态代码块，当Java虚拟机（JVM）加载类时，就会执行该代码块（用处非常大，呵呵）。1、static变量 按照是否静态的对类成员变量进行分类可分两种：一种是被static修饰的变量，叫静态变量或类变量；另一种是没有被static修饰的变量，叫实例变量。两者的区别是： 对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。 对于实例变量，没创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。2、静态方法 静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。因为实例成员与特定的对象关联！这个需要去理解，想明白其中的道理，不是记忆！！！ 因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。3、static代码块 static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。例如： 1234567891011121314151617181920212223242526public class Test5 &#123; private static int a; private int b; static&#123; Test5.a=3; System.out.println(a); Test5 t=new Test5(); t.f(); t.b=1000; System.out.println(t.b); &#125; static&#123; Test5.a=4; System.out.println(a); &#125; public static void main(String[] args) &#123; // TODO 自动生成方法存根 &#125; static&#123; Test5.a=5; System.out.println(a); &#125; public void f()&#123; System.out.println("hhahhahah"); &#125; &#125; 运行结果：3hhahhahah100045 利用静态代码块可以对一些static变量进行赋值，最后再看一眼这些例子，都一个static的main方法，这样JVM在运行main方法的时候可以直接调用而不用创建实例。4、static和final一块用表示什么static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！对于变量，表示一旦给值就不可修改，并且通过类名可以访问。对于方法，表示不可覆盖，并且可以通过类名直接访问。 【自己补充的】5、static还可以修饰内部类，普通类是不允许声明为静态的，只有内部类才可以。被static修饰的内部类可以直接作为一个普通类来使用，而不需实例化一个外部类例如有个类 123456class TestInner&#123;static class StaticInnerClass&#123;&#125;class InnerClass&#123;&#125;&#125; 那么在main中实例化StaticInnerClass的代码是这样写new TestInner.StaticInnerClass();而实例化InnerClass则必须写成TestInner testInner = new TestInner();testInner.new InnerClass();所以要注意了哦！而且呢，在InnerClass里面已经无法再声明static innner class了，因为The member type inner cannot be declared static; static types can only be declared in static or top level types 抽象类 abstract class 包含抽象方法的类，叫抽象类。而抽象的概念就是抽象出共同属性：成员变量和方法。所以抽象类可以有private等多种权限的成员变量和非abstract的成员方法。当然抽象方法是一定要有的。 抽象类是用于单一继承的，不能实例化。而继承类一定要实现抽象方法，因为抽象方法在抽象类里是没有实现行为的，访问权限只能是public。而非抽象方法则可以赋予方法的默认行为，访问权限可以多种，但需要考虑非抽象方法是否需要被继承类访问。接口 interface 接口，用于多重继承，也不能实例化。只能包含static final的成员变量，不过在interface中一般不定义成员变量。而成员方法在接口里只能是抽象方法，访问权限只能是public。http://android.blog.51cto.com/268543/385282/]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android编码规范]]></title>
    <url>%2F2018%2F06%2F11%2Fandroid%2Fandroid-code-style%2F</url>
    <content type="text"><![CDATA[Android编码规范 Android快速开发框架 Android组件化设计思路]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>Android编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初始化git仓库项目.md]]></title>
    <url>%2F2018%2F06%2F11%2Fgit%2F%E5%88%9D%E5%A7%8B%E5%8C%96git%E4%BB%93%E5%BA%93%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[常用 Git 命令清单 Command line instructions 命令行指令Git global setup12git config --global user.name &quot;xxx&quot;git config --global user.email &quot;xxx@email.com&quot; Create a new repository123456git clone git@git.jd.com:xxx/yyy.gitcd JDViewKitDoctouch README.mdgit add README.mdgit commit -m &quot;add README&quot;git push -u origin master Existing folder123456cd existing_foldergit initgit remote add origin git@git.jd.com:xxx/yyy.gitgit add .git commit -m &quot;Initial commit&quot;git push -u origin master Existing Git repository1234cd existing_repogit remote add origin git@git.jd.com:xxx/yyy.gitgit push -u origin --allgit push -u origin --tags 问题解决方案fatal: refusing to merge unrelated histories 解决方案解决方案可以使用 rebase 的方式来进行合并。 1git pull --rebase origin master 1234567891011cdmkdir rebaseTmpcd rebaseTmpecho &quot;hello a line&quot; &gt; tmp.txtgit initgit add .git commit -m &quot;Local first commit&quot;git remote add origin https://github.com/HustLion/java_console_log4j.gitgit pull --rebase origin mastergit push -u origin master]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git仓库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 如何删除缓存的远程分支列表.md]]></title>
    <url>%2F2018%2F06%2F11%2Fgit%2Fgit%20%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%E7%9A%84%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[常用 Git 命令清单 列出远程分支使用git 部署代码， git branch -a 里面列出的很多远程的分支，其实都是已经被删除了的。 删除缓存的远程分支列表用此命令：123git remote prune originorgit fetch -p 即可解决 列出提交个数1git rev-list --count HEAD]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git删除缓存远程分支</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[weex compile + 访问]]></title>
    <url>%2F2018%2F06%2F11%2Fvue%20%26%20weex%2Fweex%20compile%20%2B%20%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[本地启的服务测试（访问地址）：http://xxxx/jsTest/PromotionHome.js xxxx/jsTest 本地服务地址 + 存放js的目录 vue到js文件编译拷贝两步骤：weex compile PromotionHome.vue PromotionHome.jscp PromotionHome.js /Library/WebServer/Documents/jsTest]]></content>
      <categories>
        <category>weex</category>
      </categories>
      <tags>
        <tag>weex 编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[weex 工作原理]]></title>
    <url>%2F2018%2F06%2F11%2Fvue%20%26%20weex%2Fweex%20%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[weex 工作原理123transformer 会把 template, style, script 都转换成一段段 json 或者 js，这样客户端只接收并运行js，不必同时解析html/css这些语法，并且这些js还会继续进行数据监听和绑定，然后生成最终的virtual dom 再发送给 native端进行渲染。 weex 主要就是做了三件事 在服务端用 Transformer 工具把 Vue 代码转换成 Js Bundle。 在客户端运行Js Framework 的 JavaScript 引擎，解释执行Js Bundle生成Virtual DOM。 在客户端设计一套 JS Bridge，能使IOS端（或者Android端）的Object-C语言（或Java语言）与Javascript语言相互调用，把Virtual Dom转换为DOM，渲染到页面。H5端直接和Js Framework 通讯，不需要Js Bridge。如下为Virtual DOM 渲染为Dom的过程： 相关概念：1234ECMAScript：定义了JavaScript语言的标准JavaScriptCore：应用在在wekit内核内的js引擎，浏览器有Safari。V8: 应用在chromium内的js引擎，浏览器有Chrome。JS引擎的作用都是解释和执行JavaScript代码。 有关JavaScript引擎解析的内容请查看 JavaScriptCore解析 有关JavaScriptCore和V8的内容请查看：JavaScript引擎 怎么开始搭建个weex项目相对比较简单看官方吧。weex相关工具 123node.jsweex-toolkitWeex Playground App 相关论坛weex 文章weex 调试weex 文档：weex中使用数据流工具Vuex实践weex交流室]]></content>
      <categories>
        <category>weex</category>
      </categories>
      <tags>
        <tag>weex 工作原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm更换镜像]]></title>
    <url>%2F2017%2F12%2F04%2Fnode.js%2Fnpm%E6%9B%B4%E6%8D%A2%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[由于不可说原因，npm install时，速度总是不尽如人意，解决办法是修改npm的数据源npm config set registry https://registry.npm.taobao.org 开发ReactNative项目，搭建环境时通过如下代码将npm设置成淘宝镜像终端直接设置 12npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global 或者 编辑 ~/.npmrc 加入下面内容 1registry = http://registry.cnpmjs.org 修改后可以通过这个进行测试npm config get registry npm config get registry npm配置镜像、设置代理]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>npm更换镜像</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[python爬虫-scarpy]]></title>
    <url>%2F2017%2F05%2F19%2Fpython%2Fpython%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[scrapy基础实例，爬取zhipin网站信息 scarpy的新建 + scarpy模拟登录 + 在pipeline中存取信息到sqlite3 +xpath解析页面 文档 Scrapy Documentation Scrapy 0.25 中文翻译 环境 python3.5.2 + scrapy1.3 scrapy新建工程1scrapy startproject projectName 具体可以查看 python3爬虫学习 发现 parse 或者 start_requests是爬虫的入口 解析htmlscrapy支持xpath 和 css 两种选择器。这里使用xpath。 比如 这个页面 我们要获取页面上帖子的链接： 12345678910... def parse_page(self, response): print("\n 开始 解析版面上的具体招聘帖子的链接\n") selector = scrapy.Selector(response) job_list = selector.xpath("//div[@class='job-list']/ul[1]/li/a") for job_list_content in job_list: url = self.host + job_list_content.xpath("@href").extract_first() print("\n帖子 链接是: "+url+"\n") 这样就或获取到帖子的链接 递归如何解析帖子链接的内容，并且递归到下一页呢？这里需要使用yield：1yield scrapy.Request(url=url, callback=self.parse_page) scrapy会自行调度，并访问该url然后把内容拿回来 具体代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445class TestZhiPinSpider2(scrapy.Spider): name = "TestZhiPinSpider2" host = "https://www.zhipin.com" # 这个例子中只指定了一个页面作为爬取的起始url # 当然从数据库或者文件或者什么其他地方读取起始url也是可以的 start_urls = [ "https://www.zhipin.com/job_detail/?query=iOS&amp;scity=101210100" ] # 爬虫的入口，可以在此进行一些初始化工作，比如从某个文件或者数据库读入起始url def start_requests(self): print(" 开始解析url ----------------------------------------------------------------------------------------") for url in self.start_urls: # 此处将起始url加入scrapy的待爬取队列，并指定解析函数 # scrapy会自行调度，并访问该url然后把内容拿回来 yield scrapy.Request(url=url, callback=self.parse_page) # 版面解析函数，解析一个版面上的帖子的标题和地址 def parse_page(self, response): print("解析 parse_page ----------------------------------------------------------------------------------------") selector = scrapy.Selector(response) job_list = selector.xpath("//div[@class='job-list']/ul[1]/li/a") for job_list_content in job_list: url = self.host + job_list_content.xpath("@href").extract_first() print("帖子 链接是: "+url) # 此处，将解析出的帖子地址加入待爬取队列，并指定解析函数 yield scrapy.Request(url=url, callback=self.parse_job_detail) # 在此处解析翻页信息，从而实现爬取版区的多个页面 next_page_url = selector.xpath("//a[@ka='page-next']").xpath("@href").extract_first() next_page_class = selector.xpath("//a[@ka='page-next']").xpath("@class").extract_first() if next_page_class == "next": next_page_full_url = self.host + next_page_url yield scrapy.Request(url=next_page_full_url, callback=self.parse_page) else: print("没有下一页了----------------------------------------------------------------------------") #具体的招聘信息 def parse_job_detail(self, response): selector = scrapy.Selector(response) job_url = response.request.url print(" 解析 具体的招聘信息 --------url:"+job_url) 这个爬虫会将zhipin网站iOS招聘的信息都爬取一遍 Pipelines可以看到新建工程后会生成一个pipelines.py的文件，可以在这里处理抓取的内容，存入数据库什么的。 1.在items.py中定义抓取的内容这里简单写一个 12class TestJobDetailItem(Item): url = Field() 2.在pipelines中处理在pipelines.py中新建Sqlite3Pipeline方法，原来可能有个FilePipeline不理它。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from jobSpider.items import JobDetailItemfrom jobSpider.items import TestJobDetailItemimport sqlite3import osimport shutilfrom collections import OrderedDictclass Sqlite3Pipeline(object): def __init__(self, sqlite_file, sqlite_base_file, sqlite_ZhiPin_table, sqlite_Test_ZhiPin_table): self.sqlite_file = sqlite_file self.sqlite_base_file = sqlite_base_file self.sqlite_ZhiPin_table = sqlite_ZhiPin_table self.sqlite_Test_ZhiPin_table = sqlite_Test_ZhiPin_table @classmethod def from_crawler(cls, crawler): return cls( sqlite_file = crawler.settings.get('SQLITE_FILE_PATH'), # 从 settings.py 提取 sqlite_base_file=crawler.settings.get('SQLITE_BASE_FILE_PATH'), sqlite_ZhiPin_table = crawler.settings.get('SQLITE_ZHI_PIN_ITEM_TABLE'), sqlite_Test_ZhiPin_table=crawler.settings.get('SQLITE_TEST_ZHI_PIN_ITEM_TABLE') ) def open_spider(self, spider): print("\n 连接数据库 \n") self.create_sql_db() self.conn = sqlite3.connect(self.sqlite_file) self.cur = self.conn.cursor() def close_spider(self, spider): print("\n 关闭数据库 \n") self.conn.close() def process_item(self, item, spider): print("\n Sqlite3Pipeline process_item\n") if isinstance(item, TestJobDetailItem): print(" sqlite3 处理 TestJobDetailItem ") orderedDict = OrderedDict(sorted(item.items(), key=lambda t: t[0])) keys = list(orderedDict.keys()) values = list(orderedDict.values()) insert_sql = "insert into &#123;0&#125;(&#123;1&#125;) values (&#123;2&#125;)".format(self.sqlite_ZhiPin_table, ', '.join(keys), ', '.join(['?'] * len(keys))) self.cur.execute(insert_sql, values) self.conn.commit() return item else: print(" item 类型不对 sqlite3不处理") return item def create_sql_db(self): #复制原始数据库，（也可以直接新建一个，只不过懒得写SQL…… sql_db_path = os.path.abspath(self.sqlite_file) sql_base_db_path = os.path.abspath(self.sqlite_base_file) print("\n create_sql_db \n ", sql_db_path, sql_base_db_path) if not os.path.exists(sql_db_path): shutil.copyfile(sql_base_db_path, sql_db_path) 这里例子详细写了将抓取数据写入数据库，这里用的是sqlite3。可以换成文件csv，mysql什么的。 3.在Setting中配置一下找到settings.py 写入：12345#数据库信息SQLITE_FILE_PATH = '/Users/sts/Desktop/github/pythonWorkSapce/jobSpider/jobSpider/sqlite/Item_use.sqlite'SQLITE_BASE_FILE_PATH = '/Users/sts/Desktop/github/pythonWorkSapce/jobSpider/jobSpider/sqlite/Item_base.sqlite'SQLITE_ZHI_PIN_ITEM_TABLE = 'ZhiPinJobDetail'SQLITE_TEST_ZHI_PIN_ITEM_TABLE = 'TestZhiPin' 和1234# 配置pipelineITEM_PIPELINES = &#123; 'jobSpider.pipelines.Sqlite3Pipeline': 400,&#125; 这里可以配置多个pipeline，后面的数字表示优先级。scrapy会根据优先级，把item依次交给各个pipeline来处理。 4.在爬虫中调用这个pipeline在上面递归例子中，加入 yield item 12345678910111213from jobSpider.items import JobDetailItem... #具体的招聘信息 def parse_job_detail(self, response): selector = scrapy.Selector(response) job_url = response.request.url print(" 解析 具体的招聘信息 --------url:"+job_url) item = TestJobDetailItem() item["url"] = job_url yield item scrapy会把这个item交给我们刚刚写的FilePipeline来处理. 登录 很多爬虫信息都要登录后才能抓取，这里也将登录模拟一遍，还是用 zhipin 网站。使用zhipin网站的账号密码登陆模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 # 测试登录 login_url = "https://www.zhipin.com/user/login.html?ka=header-login" login_post_url = "https://www.zhipin.com/login/account.json" host = "https://www.zhipin.com" def start_requests(self): yield scrapy.Request(url=self.login_url, meta=&#123;'cookiejar': 1&#125;, callback=self.request_captcha) #获取验证码 这里简单使用手动输验证码 def request_captcha(self, response): selector = scrapy.Selector(response) captcha_url = selector.xpath("//img[@class='verifyimg']").xpath("./@src").extract_first() randomKey = selector.xpath("//input[@class='randomkey']").xpath("./@value").extract_first() full_captcha_url = self.host + captcha_url fileName = self.captcha_file_path() urlretrieve(full_captcha_url, fileName) open_image_command = "open "+fileName os.system(open_image_command) captcha_str = input("请输入验证码:") return scrapy.FormRequest.from_response( response, formdata=&#123;"regionCode": "+86", "account": "手机号", "password": "密码", "captcha": captcha_str, "randomKey": randomKey&#125;, meta=&#123;'cookiejar': response.meta['cookiejar']&#125;, callback=self.after_login )# self.open_host_page 就是开始爬的方法 def after_login(self, response): print("after_login") yield scrapy.Request(url=self.host, meta=&#123;'cookiejar': response.meta['cookiejar']&#125;, callback=self.open_host_page) #验证码图片保存路径 def captcha_file_path(self): captcha_file_name = "./image/captcha.jpg" directory = os.path.dirname(captcha_file_name) if not os.path.exists(directory): os.makedirs(directory) return captcha_file_name setting的一些配置1234567891011121314# 间隔时间，单位秒。指明scrapy每两个请求之间的间隔。DOWNLOAD_DELAY = 5# 对一个网站的最大并发数CONCURRENT_REQUESTS_PER_DOMAIN = 16# 对一个IP的最大并发数CONCURRENT_REQUESTS_PER_IP = 16# 请求头DEFAULT_REQUEST_HEADERS = &#123; 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Language': 'zh-CN,zh;q=0.8,en;q=0.6', 'Accept-Encoding':'gzip, deflate, sdch, br', 'Connection': 'keep-alive', 'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36'&#125; 最后就可以爬取到所需要的招聘信息了： 具体代码查看： https://github.com/sunyanyan/jobSpider]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python3-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习]]></title>
    <url>%2F2017%2F05%2F19%2Fpython%2Fpython%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Python基础知识总结12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152--&gt;首先python是用缩进来解读程序的，所以缩进很重要--&gt;%d %s 分别表示打印整数和字符串--&gt;print 直接打印--&gt;def 方法名: 声明方法--&gt;if __name__ == &apos;__main__&apos;: 这个感觉想是主方法--&gt;r或R 字符串前缀加上r或R表示自然字符串 打印输出一下就明白意思了 print &quot;============Newlines are indicated by \n&quot; print r&quot;============Newlines are indicated by \n&quot;--&gt;列表 空列表：a=[] 函数方法：a.append(3) &gt;&gt;&gt;[3] a.extend([3,4,5]) &gt;&gt;&gt;[3,3,4,5] 添加一个列表序列 a.insert(1,&apos;hello&apos;) &gt;&gt;&gt;[3,&apos;hello&apos;,3,4,5] a.remove(3) &gt;&gt;&gt;[&apos;hello&apos;,3,4,5] 删除第一个出现的3，没有3则报错 a.pop() &gt;&gt;&gt;[&apos;hello&apos;,3,4] a.pop(0) &gt;&gt;&gt;[3,4] a.index(4) &gt;&gt;&gt;1 返回出现的第一个4的下标 a.count(3) &gt;&gt;&gt;1 列表中元素3的个数 a.sort &gt;&gt;&gt;[3,4] 排序 a.reverse() &gt;&gt;&gt;[4,3] 反序 删除元素的方法 a.remove(3) 通过值删除元素，删除第一个为参数值得元素 a.pop() 通过下标删除元素，默认删除列表最后一个值，带参数则删除下标为参数值的元素 del a[0] 通过下标删除元素， del a[2:4] 删除a表下标为2,3的元素 del a[:] 删除a列表所有元素 del a 删除列表--&gt;元组 空元组：t = () 元组赋值： t = (123,345) t[0] &gt;&gt;&gt;123--&gt;字典 d = &#123;&apos;Jack&apos;:&apos;jack@mail.com&apos;,&apos;Tom&apos;:&apos;Tom@main.com&apos;&#125; d[&apos;Jack&apos;] &gt;&gt;&gt;&apos;jack@mail.com d[&apos;Jim&apos;] = &apos;Jim@sin.com&apos; &gt;&gt;&gt;&#123;&apos;Jim&apos;: &apos;Jim@sin.com&apos;, &apos;Jack&apos;: &apos;jack@mail.com&apos;, &apos;Tom&apos;: &apos;Tom@main.com&apos;&#125; del d[&apos;Jim&apos;] &gt;&gt;&gt;&#123;&apos;Jack&apos;: &apos;jack@mail.com&apos;, &apos;Tom&apos;: &apos;Tom@main.com&apos;&#125; list(d.keys()) 将返回一个字典中所有关键字组成的无序列表 sorted(d.keys()) 将返回一个字典中所有关键字组成的排序列表 dict() 构造函数可以直接从key-value对中创建字典 dict([(&apos;Tim&apos;,123),(&apos;Tiny&apos;,234)]) &gt;&gt;&gt;&#123;&apos;Tiny&apos;: 234, &apos;Tim&apos;: 123&#125;--&gt;字符串相关知识 addressStr = &quot;%s%s%s&quot; %(village_name,village_period,build_number) 特殊字符的删除 identify = string.maketrans(&apos;&apos;, &apos;&apos;) delEStr = string.punctuation + &apos; &apos; + string.digits #ASCII 标点符号，空格和数字 s = s.translate(identify, delEStr) #去掉ASCII 标点符号和空格 4种类型的数1234561、在Python中有4种类型的数——整数、长整数、浮点数和复数。2是一个整数的例子。长整数不过是大一些的整数。3.23和52.3E-4是浮点数的例子。E标记表示10的幂。在这里，52.3E-4表示52.3 * 10-4。(-5+4j)和(2.3-4.6j)是复数的例子。 字符串12345678910111213141516171819202122232425262728293031323334353637383940414243字符串是 字符的序列 。字符串基本上就是一组单词。我几乎可以保证你在每个Python程序中都要用到字符串，所以请特别留心下面这部分的内容。下面告诉你如何在Python中使用字符串。使用单引号（&apos;）你可以用单引号指示字符串，就如同&apos;Quote me on this&apos;这样。所有的空白，即空格和制表符都照原样保留。使用双引号（&quot;）在双引号中的字符串与单引号中的字符串的使用完全相同，例如&quot;What&apos;s your name?&quot;。使用三引号（&apos;&apos;&apos;或&quot;&quot;&quot;）利用三引号，你可以指示一个多行的字符串。你可以在三引号中自由的使用单引号和双引号。例如：&apos;&apos;&apos;This is a multi-line string. This is the first line.This is the second line.&quot;What&apos;s your name?,&quot; I asked.He said &quot;Bond, James Bond.&quot;&apos;&apos;&apos;转义符假设你想要在一个字符串中包含一个单引号（&apos;），那么你该怎么指示这个字符串？例如，这个字符串是What&apos;s your name?。你肯定不会用&apos;What&apos;s your name?&apos;来指示它，因为Python会弄不明白这个字符串从何处开始，何处结束。所以，你需要指明单引号而不是字符串的结尾。可以通过 转义符 来完成这个任务。你用\&apos;来指示单引号——注意这个反斜杠。现在你可以把字符串表示为&apos;What\&apos;s your name?&apos;。另一个表示这个特别的字符串的方法是&quot;What&apos;s your name?&quot;，即用双引号。类似地，要在双引号字符串中使用双引号本身的时候，也可以借助于转义符。另外，你可以用转义符\\来指示反斜杠本身。值得注意的一件事是，在一个字符串中，行末的单独一个反斜杠表示字符串在下一行继续，而不是开始一个新的行。例如：&quot;This is the first sentence.\This is the second sentence.&quot;等价于&quot;This is the first sentence. This is the second sentence.&quot;自然字符串如果你想要指示某些不需要如转义符那样的特别处理的字符串，那么你需要指定一个自然字符串。自然字符串通过给字符串加上前缀r或R来指定。例如r&quot;Newlines are indicated by \n&quot;。Unicode字符串Unicode是书写国际文本的标准方法。如果你想要用你的母语如北印度语或阿拉伯语写文本，那么你需要有一个支持Unicode的编辑器。类似地，Python允许你处理Unicode文本——你只需要在字符串前加上前缀u或U。例如，u&quot;This is a Unicode string.&quot;。记住，在你处理文本文件的时候使用Unicode字符串，特别是当你知道这个文件含有用非英语的语言写的文本。字符串是不可变的这意味着一旦你创造了一个字符串，你就不能再改变它了。虽然这看起来像是一件坏事，但实际上它不是。我们将会在后面的程序中看到为什么我们说它不是一个缺点。按字面意义级连字符串如果你把两个字符串按字面意义相邻放着，他们会被Python自动级连。例如，&apos;What\&apos;s&apos; &apos;your name?&apos;会被自动转为&quot;What&apos;s your name?&quot;。 标识符的命名123456789101112变量是标识符的例子。 标识符 是用来标识 某样东西 的名字。在命名标识符的时候，你要遵循这些规则：标识符的第一个字符必须是字母表中的字母（大写或小写）或者一个下划线（‘ _ ’）。标识符名称的其他部分可以由字母（大写或小写）、下划线（‘ _ ’）或数字（0-9）组成。标识符名称是对大小写敏感的。例如，myname和myName不是一个标识符。注意前者中的小写n和后者中的大写N。有效 标识符名称的例子有i、__my_name、name_23和a1b2_c3。无效 标识符名称的例子有2things、this is spaced out和my-name。 关于模块主方法的使用1234567模块的__name__每个模块都有一个名称，在模块中可以通过语句来找出模块的名称。这在一个场合特别有用——就如前面所提到的，当一个模块被第一次输入的时候，这个模块的主块将被运行。假如我们只想在程序本身被使用的时候运行主块，而在它被别的模块输入的时候不运行主块，我们该怎么做呢？这可以通过模块的__name__属性完成。使用模块的__name__例8.2 使用模块的__name__ !/usr/bin/python Filename: using_name.py12345if __name__ == &apos;__main__&apos;: print &apos;This program is being run by itself&apos;else: print &apos;I am being imported from another module&apos; python中切片的学习123切片操作符是序列名后跟一个方括号，方括号中有一对可选的数字，并用冒号分割。注意这与你使用的索引操作符十分相似。记住数是可选的，而冒号是必须的。切片操作符中的第一个数（冒号之前）表示切片开始的位置，第二个数（冒号之后）表示切片到哪里结束。如果不指定第一个数，Python就从序列首开始。如果没有指定第二个数，则Python会停止在序列尾。注意，返回的序列从开始位置 开始 ，刚好在 结束 位置之前结束。即开始位置是包含在序列切片中的，而结束位置被排斥在切片外。 正则表达式的学习1234567891011121314151617181920212223242526272829303132333435363738394041正则表达式的学习 http://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html ①一般字符： . 匹配任意除换行符“\n”外的字符 例如：a.c -&gt; abc,acc,adc...等与之匹配 \ 转义字符，使后一个字符改变原来的意思 例如：a\.c,a\\c 与之匹配的则是a.c,a\c [...] 字符集（字符类） 对应的位置可以是字符集中任意字符，字符集中得字符可以逐个列出，也可以给出范围，如 [abc]或[a-c],第一个字符如果是^ 则表示取反，如[^abc]表示不是abc的其他字符，所有的特殊字符在字符集中都 失去其原有的特殊含义。 ②预定义字符集 -&gt; 在字符集表示方式 \d -&gt; 表示数字：[0-9] \D -&gt; 表示非数字：[^\d] \s -&gt; 表示空白字符：[&lt;空格&gt;\t\r\n\f\v] \S -&gt; 表示非空白符：[^\s] \w -&gt; 表示单词字符: [A-Za-z0-9_] \W -&gt; 表示非单词字符：[^\w] ③数量词（用在字符或（...）之后） * -&gt; 表示：匹配前一个字符0或无限次 例如：abc* 表示ab、abcccccc等 + -&gt; 表示：匹配前一个字符一次或无限次 例如 abc+ 表示abc、abcccccc等 ？ -&gt; 表示：匹配前一个字符0次或一次。例如：abc？ 表示ab、abc &#123;m&#125; -&gt; 表示：匹配前一个字符m次。 例如：ab&#123;2&#125;c 表示abbc &#123;m,n&#125; -&gt; 表示：匹配前一个字符m至n次。m和n可以省略：若省略m则匹配0至n次，反之则匹配m至无限次。例如：ab&#123;1,2&#125; 表示abb、ab ④边界匹配（不消耗待匹配字符串中得字符） ^ -&gt; 表示：匹配字符串开头。在多行模式中匹配每一行的开头 例如：^abc 表示abc $ -&gt; 表示：匹配字符串末尾。在多行模式中匹配每一行的末尾 例如：abc$ 表示abc \A -&gt; 表示：仅匹配字符串开头。例如：\Aabc 表示abc \Z -&gt; 表示：仅匹配字符串末尾。例如：\Zabc 表示abc \b -&gt; 表示：匹配\w和\W之间。例如：a\b!bc 表示a!bc \B -&gt; 表示：[^\b]。例如：a\Bbc 表示abc ⑤逻辑、分组 | -&gt; 表示左右表达式任意匹配一个。它总是先尝试匹配左边的表达式，一旦成功匹配则跳过匹配右边的表达式。如果|没有别包括在（）中，则它的范围是整个正则表达式 例如：abc|def (...) -&gt; 被括起来的表达式将作为分组，从表达式的左边开始每遇到一个分组的左括号‘（’，编号+1. 另外，分组表达式作为一个整体，可以后接数量词。表达式|仅在该组中有效：（abc）&#123;2&#125; abcabc (?P&lt;name&gt;...) -&gt; 分组，除了原有的编号外在指定一个额外的别名。 例如：(?P&lt;id&gt;abc)&#123;2&#125; abcabc \&lt;number&gt; -&gt; 表示 引用编号为&lt;number&gt;的分组匹配到得字符串。例如：(\d)abc\1 则可表：2abc2、4abc4 (?P=name) -&gt; 表示 引用别名为&lt;name&gt;的分组匹配到得字符串。(?P&lt;id&gt;\d)abc(?P=id) 则可表：2abc2、4abc4 ⑥特殊构造（不作为分组） (?:...) -&gt; 表（...）的不分组版本，用于使用‘|’或后接数量词。 例如：(?:abc)&#123;2&#125; abcabc (?:iLmsux) -&gt; 表 iLmsux的每一个字符代表一个匹配模式，只能用在正则表达式的开头，可选多个。 例如：(?iabc) Abc (?#...) -&gt; 表 #后的内容将作为注释被忽略。 例如：abc(?#comment)123 abc123 (?=...) -&gt; 表 之后的字符串内容需要匹配表达式才能成功匹配。不消耗字符串内容 例如：a(?=\d) 后面是数字的a (?!...) -&gt; 表 之后的字符串内容需要不匹配表达式才能成功匹配。不消耗字符串内容 例如：a(?!\d) 后面不是数字的a (?&lt;=...) -&gt; 表 之前的字符串内容需要匹配表达式才能成功匹配。不消耗字符串内容 例如：(&lt;=\d)a 前面是数字的a (?&lt;!...) -&gt; 表 之前的字符串内容需要不匹配表达式才能成功匹配。不消耗字符串内容 例如：(&lt;=\d)a 前面不是数字的a grep的使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556grep的使用： 1、使用正则表达式的一个多用途文本搜索工具. 2,grep的选项 -c 只输出匹配行的计数 -i 不区分大小写（用于单字符） -n 显示匹配的行号 -v 不显示不包含匹配文本的所以有行 -s 不显示错误信息 -E 使用扩展正则表达式 更多的选项请查看：man grep 3,常用grep实例 (1)多个文件查询 grep &quot;sort&quot; *.doc #见文件名的匹配 (2)行匹配:输出匹配行的计数 grep -c &quot;48&quot; data.doc #输出文档中含有48字符的行数 (3)显示匹配行和行数 grep -n &quot;48&quot; data.doc #显示所有匹配48的行和行号 (4)显示非匹配的行 grep -vn &quot;48&quot; data.doc #输出所有不包含48的行 (4)显示非匹配的行 grep -vn &quot;48&quot; data.doc #输出所有不包含48的行 (5)大小写敏感 grep -i &quot;ab&quot; data.doc #输出所有含有ab或Ab的字符串的行 4, 正则表达式的应用 (1)正则表达式的应用 (注意：最好把正则表达式用单引号括起来) grep &apos;[239].&apos; data.doc #输出所有含有以2,3或9开头的，并且是两个数字的行 (2)不匹配测试 grep &apos;^[^48]&apos; data.doc #不匹配行首是48的行 (3)使用扩展模式匹配 grep -E &apos;219|216&apos; data.doc (4) ... 这需要在实践中不断应用和总结，熟练掌握正则表达式。 5, 使用类名 可以使用国际模式匹配的类名： [[:upper:]] [A-Z] [[:lower:]] [a-z] [[:digit:]] [0-9] [[:alnum:]] [0-9a-zA-Z] [[:space:]] 空格或tab [[:alpha:]] [a-zA-Z] (1)使用 grep &apos;5[[:upper:]][[:upper:]]&apos; data.doc #查询以5开头以两个大写字母结尾的行 shell123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127vim的使用： vim在保存之前不会对文件做实际的修改，只是加载到缓冲区中，对文件的编辑其实是对缓冲区的编辑，直到:w时才会存入物理文件。 ( 按 i 进入 insert 状态 即插入模式 ,按 Esc 退出插入模式 在非插入模式下按 dd 删除光标当前行,按 x 删除当前字, 按 j,n,l移动光标 ) :e file 把file加载到新的缓冲区中 :bn 跳转到下一个缓冲区 :bd 删除缓冲区(关闭文件) :sp fn 分割窗口，并将fn加载到新的窗口中 退出编辑器 :w 将缓冲区写入文件，即保存修改 :wq 保存修改并退出 :x 保存修改并退出 :q 退出，如果对缓冲区进行过修改，则会提示 :q! 强制退出，放弃修改移动的使用：mv [选项] 源文件或目录 目标目录拷贝的使用： cp [选项] 源文件或目录 目标文件或目录删除的使用： rm rm -r vv 但是这样会询问你是否真的要删除vv目录 输入y 确认删除 为了不让系统询问，可以强制删除 rm之后加上f就行了 rm -rf vv 这样就强制删除目录vv 如果目录下还有其他文佳 也一同删除了cat的使用：（concatenate） cat主要有三大功能： 1.一次显示整个文件。$ cat filename 2.从键盘创建一个文件。$ cat &gt; filename 只能创建新文件,不能编辑已有文件. 1、键入cat &gt; filename.txt 后回车 2、录入文本内容； 3、键入回车； 4、在键盘上按下Ctrl+D (或者键入Control－D)。 5、 文本被存盘，shell提示符重新出现 3.将几个文件合并为一个文件： $cat file1 file2 &gt; file 参数： -n 或 --number 由 1 开始对所有输出的行数编号 -b 或 --number-nonblank 和 -n 相似，只不过对于空白行不编号 -s 或 --squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行 -v 或 --show-nonprinting 例： 把 textfile1 的档案内容加上行号后输入 textfile2 这个档案里 cat -n textfile1 &gt; textfile2 把 textfile1 和 textfile2 的档案内容加上行号（空白行不加）之后将内容附加到 textfile3 里。 cat -b textfile1 textfile2 &gt;&gt; textfile3 cat /dev/null &gt; /etc/test.txt 把test.txt文件扔进垃圾箱 mkdir的使用: linux mkdir 命令用来创建指定的名称的目录，要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录。 1．命令格式： mkdir [选项] 目录... 2．命令功能： 通过 mkdir 命令可以实现在指定位置创建以 DirName(指定的文件名)命名的文件夹或目录。要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限。 并且，所创建的文件夹(目录)不能与其父目录(即父文件夹)中的文件名重名，即同一个目录下不能有同名的(区分大小写)。 3．命令参数： -m, --mode=模式，设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask -p, --parents 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录; -v, --verbose 每次创建新目录都显示信息 --help 显示此帮助信息并退出 --version 输出版本信息并退出 rmdir的使用: rmdir是一个与mkdir相对应的命令。mkdir是建立目录，而rmdir是删除命令。rm命令可以同时删除文件或目录 rmdir命令介绍 1.名称：rmdir 2.适用对象：具有当前目录操作权限的所有使用者 3.命令格式：rmdir [-p -v] [dirName] 4.作用：删除空目录 5.参数详解： -p 当子目录被删除后如果父目录也变成空目录的话，就连带父目录一起删除。 -v 上次讲过，这里不再叙述，具体参见 chmod的使用: 指令名称 : chmod 使用权限 : 所有使用者 使用方式 : chmod [-cfvR] [--help] [--version] mode file... 说明 : Linux/Unix 的档案调用权限分为三级 : 档案拥有者、群组、其他。利用 chmod 可以藉以控制档案如何被他人所调用。 参数 : mode : 权限设定字串，格式如下 : [ugoa...][[+-=][rwxX]...][,...]，其中 u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 + 表示增加权限、- 表示取消权限、= 表示唯一设定权限。 r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。 -c : 若该档案权限确实已经更改，才显示其更改动作 -f : 若该档案权限无法被更改也不要显示错误讯息 -v : 显示权限变更的详细资料 -R : 对目前目录下的所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更) --help : 显示辅助说明 --version : 显示版本 例子： chmod 755 a.txt (你必须是文件a.txt的拥有者才能运行此命令。或者以$sudo chmod 755 a.txt的方式，以超级用户的身份运行该命令。) change mode 改变a.txt的读、写以及执行权限。还记得每个文件都有九位的读写执行权限(参看 Linux文件管理背景知识)， 分为三组，分别对应拥有者(owner)，拥有组(owner group)中的用户和所有其他用户(other)。在这里，我们也有三个数字，755，对应三个组。 7被分配给拥有者，5被分配给拥有组，最后一个5分配给其它用户。Linux规定: 4为有读取的权利，2为有写入的权利， 1为有执行的权利。我们看到的7实际上是4 + 2 + 1，表示拥有者有读、写、执行三项权利。 ln的使用: ln是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同不的链接，这个命令最常用的参数是-s，具体用法是：ln –s 源文件 目标文件。 当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。例如：ln –s /bin/less /usr/local/bin/less -s 是代号（symbolic）的意思。 这里有两点要注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；第二，ln的链接又 软链接和硬链接两种， 软链接就是ln –s ** **，它只会在你选定的位置上生成一个文件的镜像， 不会占用磁盘空间，硬链接ln ** **，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。 ping的使用：（control + c 停止ping） 惯用的关机指令：shutdown ,shutdown -h now 重新开机，关机：reboot, halt, poweroff clear的使用：清空终端信息 history的使用：查看输入的历史命令 touch的使用: touch a.txt 如果a.txt不存在，生成一个新的空文档a.txt。如果a.txt存在，那么只更改该文档的时间信息。(这个命令实际上用得并不广泛，但可以帮我们创建一个空文件]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python3-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python爬取网站内容]]></title>
    <url>%2F2017%2F05%2F19%2Fpython%2Fpython%E7%88%AC%E5%8F%96%E7%BD%91%E7%AB%99%E5%B0%8F%E8%AF%B4%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[需要的库12requestsBeautifulSoup 导入方式12import requestsfrom bs4 import BeautifulSoup Requests快速上手Beautiful Soup 中文文档]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python3-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索并替换]]></title>
    <url>%2F2017%2F05%2F19%2Fpython%2Fpython%E6%90%9C%E7%B4%A2%E5%B9%B6%E6%9B%BF%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[搜索并替换123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/python# -*- coding: utf-8 -*-import osimport imghdrimport resuffix_list = ['m', 'h']g_totalCount = 0image_name = ''def replace_in_path(filepath): global g_totalCount, image_name # print("Operation with : " + filepath) # open_file = open(filepath, 'r+') #用此种打开读写方式无效 with open(filepath, 'r') as r: lines = r.readlines() with open(filepath, 'w') as w: for l in lines: r_pattern = r"\[\[Resources sharedResources\] getImageWithImageName:(.+?)\]" # if re.search(r_pattern, l): print '*******find*******' image_name_list = re.findall(r_pattern, l) if len(image_name_list): image_name = image_name_list[0] print("image_name:%s" % image_name) # replace_reg = re.compile(r_pattern) new_str = "JDImg(%s)" % image_name have_replace_string = replace_reg.sub(new_str, l) # w.write(have_replace_string) w.close()def get_file_from_dir(dir): global g_totalCount for root, dirs, files in os.walk(dir): for item in files: filepath = os.path.join(root, item) # print 'filepath------%s' % filepath extension = os.path.splitext(filepath)[1][1:] if extension in suffix_list: replace_in_path(filepath) print '找到了------后缀为：[h or m]' print '###############结束##############'if __name__ == '__main__': print "当前目录:%s" % os.getcwd() # 递归遍历目录下所有文件 get_file_from_dir('/Users/wenyongjun/JD/JDiPad_git/JDiPad')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>搜索并替换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把json写入本地文件]]></title>
    <url>%2F2017%2F05%2F19%2Fpython%2Fpython%20%E5%86%99%E5%85%A5json%E6%96%87%E4%BB%B6%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[json中文ASCII乱码问题的解决1234* json中文ASCII乱码问题的解决import sysreload(sys)sys.setdefaultencoding( "utf-8" ) 判断路径是否存在(存在:True,不存在:False)1234567891011121314def create_dir(path): # 去除首位空格 path = path.strip() # 去除尾部 \ 符号 path = path.rstrip("\\") isExists = os.path.exists(path) if not isExists: os.makedirs(path) print path + ' good 创建成功' return True else: print path + ' 该目录已存在拉' return False 删除文件12345678910111213def del_file(path): isExists = os.path.exists(path) if not isExists: return ls = os.listdir(path) for i in ls: c_path = os.path.join(path, i) if os.path.isdir(c_path): del_file(c_path) else: os.remove(c_path) shutil.rmtree(path) 将数据转换成字符串def test(): test_dict = {'one': ['你好', {1: [['jd', 'hello'], ['cmo', 'china'], ['shanghai', 'mjgc']]}]} print(test_dict) print(type(test_dict)) # dumps 将数据转换成字符串 json_str = json.dumps(test_dict) print(json_str) print(type(json_str)) os模块popen方法 可以直接使用终端的命令 例如：# 打开目录 open_path = ‘open ‘ + output_dir_name os.popen(open_path)python调用shell命令 popen方法可以得到shell命令的返回值。os.popen(cmd)后， 须要再调用read()或者readlines()这两个命令。输出结果。 os.popen("ls")]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>json文件中文乱码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是cocoapods]]></title>
    <url>%2F2016%2F06%2F11%2FiOS%2F%E4%BB%80%E4%B9%88%E6%98%AFCocoaPods%2F</url>
    <content type="text"><![CDATA[产生背景什么是CocoaPods12345CocoaPods是一个用来帮助我们管理第三方依赖库的工具。它可以解决库与库之间的依赖关系，下载库的源代码，同时通过创建一个Xcode的workspace来将这些第三方库和我们的工程连接起来，供我们开发使用。使用CocoaPods的目的是让我们能自动化的、集中的、直观的管理第三方开源库。 为什么需要CocoaPods12345678 在进行iOS开发的时候，总免不了使用第三方的开源库，比如SBJson、AFNetworking、Reachability等等。使用这些库的时候通常需要： 下载开源库的源代码并引入工程 向工程中添加开源库使用到的framework 解决开源库和开源库以及开源库和工程之间的依赖关系、 检查重复添加的framework等问题 如果开源库有更新的时候，还需要将工程中使用的开源库删除，重新执行前面的三个步骤 CocoaPods的安装 1、安装 CocoaPods是用Ruby实现的，要想使用它首先需要有Ruby的环境。 幸运的是OS X系统默认的已经可以运行Ruby了，因此我们只需要执行以下命令： $ sudo gem install cocoapods CocoaPods是以Ruby gem包的形式被安装的。在安装执行的过程中， 可能会问我们是不是更新rake，输入y即可。这是因为rake gem包会在安装的过程中检查更细， 如果有可用的新版本就会出现刚才的选项。 在安装进程结束的时候，执行命令： $ pod setup 2、安装过程中可能遇到的问题 执行完install命令半天没反应 ---被墙了 gem版本过老 ---- sudo gem update --system 安装完成后，执行pod setup命令时报错：rvm use ruby-1.9.3-p448 3、升级CocoaPods sudo gem install cocoapods CocoaPods的使用： 1、创建Podfile cd到项目目录 touch Podfile 2、编辑Podfile 3、开始安装 pod install 安装完成后就可以使用了]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS编程习惯与风格]]></title>
    <url>%2F2016%2F06%2F11%2FiOS%2FiOS%E7%BC%96%E7%A8%8B%E4%B9%A0%E6%83%AF%E4%B8%8E%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[开发前1234首先在开发前确定好需求 对需求点分析 1、对感觉不太合理的地方 提出来或者有自己的建议 把不合理的地方阉割在开发开始之前（做愉快编程）2、分析接口 做开发前的进一步预判 开发中123456781、头文件内只包含外部模块可调用的属性或者方法2、模块构建的时候可首先按逻辑与UI交互类来区分管理（逻辑管理类、ViewController）3、.m文件 内容实现上按区域划分（#pragma mark -来区域划分） （具体可为：初始化区域、自定义视图区域、自定义方法区域、生命循环区域、回调区域等）4、视图层尽量做到封装（这样保证一个大模块都是若干小模块组合而成）5、网络请求放到逻辑管理类中，VC中只管理数据返回后的渲染6、抽象数据模型7、适当添加注释（借助VVDoc） 封装的目的代码复用，提高了代码的可维护性等 在相应的模块给dealloc 打个log 看是否有内存泄露的情况 一些有意思的写法12345678910111213141516171819202122232425261、- (void)xxxMethod &#123; if ([xxx boolValue]) &#123; //todo：xxx &#125;&#125;2、if (xxx == nil) &#123;&#125;if (xxx == NO) &#123;&#125;if (xxx == YES) &#123;&#125; 3、局部变量、实例变量、方法名 保持全名命名 不缩减 （驼峰序列）4、（估计此处也同样会有质疑声）if (xxx)&#123; //todo：something&#125;else &#123; //todo：something&#125;5 、instancetype 与 id 的使用 6、[NSNumber numberWithInt:xxx] -&gt; @xxx 等类似的形式 重构123456重构？何时重构：随时随地（事不过三）哪些情况下就要考虑重构？ 重复代码、过长的函数、函数过多的参数列、过大的类、把一些开发技巧编程一种习惯，更能编写高效率、高质量的代码 学习外部地址刘彦玮博客总结 objc禅翻译 Google 开源项目风格指南 - objc]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS-WIKI</tag>
      </tags>
  </entry>
</search>
